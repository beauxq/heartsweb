/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/AI.js":
/*!*********************!*\
  !*** ./build/AI.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CardGroup_1 = __importDefault(__webpack_require__(/*! ./CardGroup */ \"./build/CardGroup.js\"));\nconst GameHand_1 = __importDefault(__webpack_require__(/*! ./GameHand */ \"./build/GameHand.js\"));\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nclass AI {\n    constructor(gameHand, whoAmI) {\n        this.unknownCards = new CardGroup_1.default();\n        /** example:\n         *  `playerSeenVoidInSuits[2][Card.CLUBS]`\n         *  is whether player 2 has shown that they don't have any clubs */\n        this.playerSeenVoidInSuits = [];\n        /** and not played yet, removed from here when they are seen played */\n        this.cardsIPassed = [];\n        if (gameHand.hasOwnProperty(\"whoAmI\")) {\n            // copy constructor\n            const ai = gameHand;\n            this.unknownCards = new CardGroup_1.default(ai.unknownCards);\n            this.playerSeenVoidInSuits = ai.playerSeenVoidInSuits; // shallow copy, don't think I need deep copy\n            this.cardsIPassed.length = 0;\n            ai.cardsIPassed.forEach((card) => {\n                this.cardsIPassed.push(new Card_1.default(card));\n            });\n            this.gameHand = new GameHand_1.default(ai.gameHand);\n            this.whoAmI = ai.whoAmI;\n        }\n        else {\n            this.gameHand = gameHand;\n            this.whoAmI = whoAmI;\n            this.resetHand(); // just to be safe\n        }\n    }\n    /** to be called in worker where observerList has been removed */\n    observeSelf() {\n        this.gameHand.registerObserver(this);\n        // TODO: find out if I need this... I don't think I do\n    }\n    setHand(hand) {\n        this.gameHand = hand;\n    }\n    choosePassingCards() {\n        const t0 = performance.now(); // time test\n        const hand = this.gameHand.getHand(this.whoAmI);\n        const scoresForEachCombination = new Array(286).fill(0);\n        const cardsForEachCombination = new Array(286).fill([]);\n        let scoreIndex = 0;\n        for (let i = 0; i < 11; ++i) {\n            for (let j = i + 1; j < 12; ++j) {\n                for (let k = j + 1; k < 13; ++k) {\n                    const cards = [hand.at(i), hand.at(j), hand.at(k)];\n                    cardsForEachCombination[scoreIndex] = cards;\n                    const loopCount = Math.floor(AI.LEVEL / (286 * 2)) + 1;\n                    for (let simNum = loopCount; simNum > 0; --simNum) {\n                        const sim = new GameHand_1.default(this.gameHand);\n                        const simAIS = [\n                            new AI(sim, 0),\n                            new AI(sim, 1),\n                            new AI(sim, 2),\n                            new AI(sim, 3)\n                        ];\n                        sim.setHands(this.speculateHands(sim.getPassingDirection()));\n                        // passing\n                        for (let playerToPass = 0; playerToPass < 4; ++playerToPass) {\n                            if (playerToPass === this.whoAmI) {\n                                sim.pass(playerToPass, (playerToPass + this.gameHand.getPassingDirection()) % 4, cards);\n                            }\n                            else { // not the player who is simulating\n                                sim.pass(playerToPass, (playerToPass + this.gameHand.getPassingDirection()) % 4, sim.getHand(playerToPass).pickRandom(3));\n                            }\n                        }\n                        sim.receivePassedCards();\n                        // playing\n                        for (let tricks = 13; tricks > 0; --tricks) {\n                            sim.resetTrick();\n                            while (sim.turnsLeftInTrick()) {\n                                sim.playCard(simAIS[sim.getWhoseTurn()].simPlayCard());\n                            }\n                            sim.endTrick();\n                        }\n                        sim.endHand();\n                        // done playing\n                        scoresForEachCombination[scoreIndex] += sim.getScore(this.whoAmI);\n                    }\n                    ++scoreIndex;\n                }\n            }\n        }\n        let bestIndex = 0;\n        for (scoreIndex = 0; scoreIndex < 286; ++scoreIndex) {\n            if (scoresForEachCombination[scoreIndex] < scoresForEachCombination[bestIndex]) {\n                bestIndex = scoreIndex;\n            }\n        }\n        const t1 = performance.now();\n        // for testing\n        console.log(\"player \" + this.whoAmI + \" had:\");\n        hand.forEach((card) => {\n            console.log(card.str());\n        });\n        console.log(\"and chose to pass:\");\n        console.log(cardsForEachCombination[bestIndex]);\n        console.log(\"time: \" + (t1 - t0));\n        return cardsForEachCombination[bestIndex];\n    }\n    speculateHands(passingDirection) {\n        const speculatedHands = [\n            new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default()\n        ];\n        const spaceRemainingIn = [\n            this.gameHand.getHand(0).length(),\n            this.gameHand.getHand(1).length(),\n            this.gameHand.getHand(2).length(),\n            this.gameHand.getHand(3).length()\n        ];\n        // I know my own hand\n        spaceRemainingIn[this.whoAmI] = 0;\n        const whomIPassedTo = (this.whoAmI + passingDirection) % 4;\n        spaceRemainingIn[whomIPassedTo] -= this.cardsIPassed.length;\n        function nonFullHands(player) { return spaceRemainingIn[player] > 0; }\n        ;\n        // testing nonFullHands\n        // console.log(\"nonFullHands:\");\n        // console.log(0, nonFullHands(0));\n        // console.log(1, nonFullHands(1));\n        // console.log(2, nonFullHands(2));\n        // console.log(3, nonFullHands(3));\n        /** first index is suit, second is player, excludes the player speculating */\n        const handsThatAllowSuit = [];\n        for (let suit = 0; suit < 4; ++suit) {\n            handsThatAllowSuit.push([\n                (!(this.playerSeenVoidInSuits[0][suit])) && this.whoAmI !== 0,\n                (!(this.playerSeenVoidInSuits[1][suit])) && this.whoAmI !== 1,\n                (!(this.playerSeenVoidInSuits[2][suit])) && this.whoAmI !== 2,\n                (!(this.playerSeenVoidInSuits[3][suit])) && this.whoAmI !== 3\n            ]);\n        }\n        // console.log(\"handsThatAllowSuit:\");\n        // console.log(handsThatAllowSuit);\n        // console.log(\"unknown length\", this.unknownCards.length());\n        // this.unknownCards.forEach((card) => { console.log(card.str()); });\n        const allowSuitAndNonFull = []; // intersection of non-full-hands with hands that allow this suit\n        this.unknownCards.forEach((thisCard) => {\n            // console.log(\"trying to find a place for \", thisCard.str());\n            allowSuitAndNonFull.length = 0;\n            handsThatAllowSuit[thisCard.suit].forEach((allowThisSuit, player) => {\n                if (allowThisSuit && nonFullHands(player)) {\n                    allowSuitAndNonFull.push(player);\n                    // console.log(\"allowSuitAndNonFull:\", allowSuitAndNonFull);\n                }\n            });\n            if (allowSuitAndNonFull.length) {\n                const receiver = allowSuitAndNonFull[Math.floor(Math.random() * allowSuitAndNonFull.length)];\n                speculatedHands[receiver].insert(thisCard);\n                --spaceRemainingIn[receiver];\n            }\n            else { // there are no hands left that allow this suit and have space for this card\n                // console.log(\"couldn't find a place for it in one step (0 swaps)\");\n                // so we have to do some swapping\n                // find which suits are allowed in non-full hands\n                const suitsAllowedInNonFull = [false, false, false, false];\n                for (let player = 0; player < 4; ++player) {\n                    if (nonFullHands(player)) {\n                        for (let suit = 0; suit < 4; ++suit) {\n                            if (handsThatAllowSuit[suit][player]) {\n                                suitsAllowedInNonFull[suit] = true;\n                            }\n                        }\n                    }\n                }\n                // find possible cards to swap (out of those suits)\n                const possibleCards = [];\n                const fromPlayer = [];\n                // go through the hands that \"this card\" is allowed in\n                handsThatAllowSuit[thisCard.suit].forEach((allowed, player) => {\n                    if (allowed) {\n                        // go through the cards in this hand\n                        speculatedHands[player].forEach((card) => {\n                            // can this card go in a non-full hand?\n                            if (suitsAllowedInNonFull[card.suit]) {\n                                possibleCards.push(card);\n                                fromPlayer.push(player);\n                            }\n                        });\n                    }\n                });\n                if (possibleCards.length) {\n                    // do the swap\n                    const indexToSwap = Math.floor(Math.random() * possibleCards.length);\n                    /** intersection of non_full and allow swap suit */\n                    const allowSSANF = [];\n                    handsThatAllowSuit[possibleCards[indexToSwap].suit].forEach((allowed, player) => {\n                        if (allowed && nonFullHands(player)) {\n                            allowSSANF.push(player);\n                        }\n                    });\n                    // assert allowSSANF size > 0  // TODO: remove (or set up debugging)\n                    if (allowSSANF.length === 0) {\n                        console.log(\"ERROR: assertion fail, single swap, no place to put swap card\");\n                    }\n                    const receiver = allowSSANF[Math.floor(Math.random() * allowSSANF.length)];\n                    speculatedHands[receiver].insert(possibleCards[indexToSwap]);\n                    speculatedHands[fromPlayer[indexToSwap]].remove(possibleCards[indexToSwap]);\n                    // and this card in the space that was made for it\n                    speculatedHands[fromPlayer[indexToSwap]].insert(thisCard);\n                    // only the size of the non-full hand changed\n                    --spaceRemainingIn[receiver];\n                }\n                else { // no single swap possible, double swap is needed\n                    // assert: double swap is possible\n                    /* questionable assertion:\n                        There is a 3rd hand that is not involved in the previously used hands in this algorithm.\n                        One hand is full and is the only one that allows  thisCard\n                        A second hand is the only one not full and doesn't allow thisCard or any card in the first hand.\n                        The 3rd hand is full and must allow some suit that is in the first hand\n                                             and must have some suit that is allowed in the second hand. */\n                    const fullAndAllows = handsThatAllowSuit[thisCard.suit].indexOf(true); // \"1st hand\"\n                    let nonFull = 0; // \"2nd hand\"\n                    for (let player = 0; player < 4; ++player) {\n                        if (nonFullHands(player)) {\n                            nonFull = player;\n                            break;\n                        }\n                    }\n                    let thirdHand = 0;\n                    while ((thirdHand === fullAndAllows) ||\n                        (thirdHand === this.whoAmI) ||\n                        (thirdHand === nonFull)) {\n                        ++thirdHand;\n                    }\n                    // debugging assertions  // TODO: remove\n                    if (handsThatAllowSuit[thisCard.suit].filter(x => x).length !== 1) { // count 'true'\n                        console.log(\"ERROR: big assertion was wrong, hands that allow this suit != 1\"); // !\n                    }\n                    // also, number of non full hands was 1\n                    // go through third hand and find cards allowed in non-full hand\n                    const secondSwapPossibilities = [];\n                    speculatedHands[thirdHand].forEach((card) => {\n                        if (suitsAllowedInNonFull[card.suit]) {\n                            secondSwapPossibilities.push(card);\n                        }\n                    });\n                    // another of the debugging assertions  // TODO: remove\n                    if (secondSwapPossibilities.length === 0) {\n                        console.log(\"ERROR: big assertion was wrong, no cards to move from 3rd to 2nd\");\n                    }\n                    // move one of those cards to the non-full hand\n                    const secondSwap = secondSwapPossibilities[Math.floor(Math.random() *\n                        secondSwapPossibilities.length)];\n                    speculatedHands[nonFull].insert(secondSwap);\n                    speculatedHands[thirdHand].remove(secondSwap);\n                    --spaceRemainingIn[nonFull];\n                    // find cards that can be moved from first hand to third hand\n                    // possibleCards is already declared from way before and is empty\n                    speculatedHands[fullAndAllows].forEach((card) => {\n                        if (!(this.playerSeenVoidInSuits[thirdHand][card.suit])) {\n                            possibleCards.push(card);\n                        }\n                    });\n                    // another of the debugging assertions  // TODO: remove\n                    if (possibleCards.length === 0) {\n                        console.log(\"ERROR: big assertion was wrong, no cards to move from 1st to 3rd\");\n                    }\n                    // move one of those cards to the third hand\n                    const firstLevelSwap = possibleCards[Math.floor(Math.random() *\n                        possibleCards.length)];\n                    speculatedHands[thirdHand].insert(firstLevelSwap);\n                    speculatedHands[fullAndAllows].remove(firstLevelSwap);\n                    // so now it's not full and has space for this card\n                    // (it will be full right after inserting this card, so don't change space remaining)\n                    // Now, finally, we can get rid of this card\n                    speculatedHands[fullAndAllows].insert(thisCard);\n                } // done with double swap\n            } // done with any swapping\n        }); // next card\n        // put in the cards that I already knew\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            speculatedHands[this.whoAmI].insert(card);\n        });\n        this.cardsIPassed.forEach((card) => {\n            speculatedHands[whomIPassedTo].insert(card);\n        });\n        return speculatedHands;\n    }\n    resetHand() {\n        this.unknownCards.fill();\n        this.cardsIPassed.length = 0;\n        this.playerSeenVoidInSuits = [\n            [false, false, false, false],\n            [false, false, false, false],\n            [false, false, false, false],\n            [false, false, false, false]\n        ];\n    }\n    dealHands() {\n        console.log(\"seeing my dealt hand:\", this.whoAmI);\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            this.unknownCards.remove(card);\n            console.log(card.str());\n        });\n    }\n    pass(fromPlayer, _toPlayer, cards) {\n        if (fromPlayer === this.whoAmI) {\n            this.cardsIPassed = cards.slice();\n        }\n    }\n    receivePassedCards() {\n        console.log(\"seeing my cards after passing\", this.whoAmI);\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            this.unknownCards.remove(card);\n            console.log(card.str());\n        });\n    }\n    resetTrick() {\n    }\n    seeCardPlayed(card, byPlayer, showingOnlyHearts = false) {\n        // console.log(\"seeing a card played\", this.whoAmI);\n        // console.log(card.str());\n        // console.log(\"see card unknown length before:\", this.unknownCards.length());\n        this.unknownCards.remove(card);\n        // console.log(\"just removed because saw it played\");\n        // console.log(\"see card unknown length after:\", this.unknownCards.length());\n        // remove from passed cards\n        let indexInPassed = -1;\n        this.cardsIPassed.forEach((passedCard, index) => {\n            if (card.value === passedCard.value && card.suit === passedCard.suit) {\n                indexInPassed = index;\n            }\n        });\n        if (indexInPassed !== -1) {\n            this.cardsIPassed.splice(indexInPassed, 1);\n        }\n        // is player showing they have none of a suit?\n        const leadSuit = this.gameHand.getPlayedCards()[this.gameHand.getTrickLeader()].suit;\n        if (card.suit !== leadSuit) {\n            this.playerSeenVoidInSuits[byPlayer][leadSuit] = true;\n        }\n        // showing that they only have hearts?\n        if (showingOnlyHearts) {\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.CLUBS] = true;\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.DIAMONDS] = true;\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.SPADES] = true;\n        }\n    }\n    staticPlayAI() {\n        const validChoices = this.gameHand.findValidChoices();\n        if (this.gameHand.getPlayedCardCount() > 0) { // I'm not leading the trick\n            const leadCard = this.gameHand.getPlayedCards()[this.gameHand.getTrickLeader()];\n            if (validChoices[0].suit === leadCard.suit) { // I have to follow suit\n                if (validChoices[0].value < leadCard.value) { // I can play under, avoid taking it\n                    // find highest card I can avoid taking it with\n                    for (let i = validChoices.length - 1; i >= 0; --i) {\n                        if (validChoices[i].value < leadCard.value) { // this is highest card I can avoid taking it with\n                            // Q of Spades instead of K of Spades\n                            if (validChoices[i].value === 13 && // king\n                                validChoices[i].suit === Card_1.default.SPADES && // of spades\n                                i > 0 && // I have a lower spade\n                                validChoices[i - 1].value === 12 // and it's the queen\n                            ) {\n                                return validChoices[i - 1];\n                            }\n                            else { // not k and q of spades\n                                return validChoices[i]; // highest card I can avoid taking it with\n                            }\n                        }\n                    }\n                    console.log(\"ERROR: should never get here\");\n                    return validChoices[0]; // just so compiler doesn't complain about not returning a card\n                }\n                else { // I can't play under\n                    if (this.gameHand.getPlayedCardCount() < 3) { // someone else will play after me\n                        if (leadCard.suit === Card_1.default.SPADES) { // spades\n                            if (validChoices[0].value === 12 && // queen\n                                validChoices.length > 1) { // and I have something else\n                                return validChoices[1];\n                            }\n                            else { // not queen or I don't have anything else\n                                return validChoices[0];\n                            }\n                        }\n                        else { // not spades\n                            return validChoices[0];\n                        }\n                    }\n                    else { // no one else plays after me\n                        const highestCard = validChoices[validChoices.length - 1];\n                        if (leadCard.suit === Card_1.default.SPADES) { // spades\n                            if (highestCard.value === 12 && // queen\n                                validChoices.length > 1 // and I have something else\n                            ) {\n                                return validChoices[validChoices.length - 2]; // highest except queen\n                            }\n                            else { // not queen or I don't have anything else\n                                return highestCard;\n                            }\n                        }\n                        else { // not spades\n                            return highestCard;\n                        }\n                    }\n                }\n            }\n            else { // don't have to follow suit (and not leading)\n                // GET RID OF THE QUEEN!!\n                // (play lowest of high spades)\n                const highSpades = []; // ordered from highest to lowest\n                for (let i = validChoices.length - 1; i >= 0; --i) {\n                    if (validChoices[i].suit !== Card_1.default.SPADES) {\n                        continue;\n                    }\n                    if (validChoices[i].value > 11) { // higher than jack\n                        highSpades.push(validChoices[i]);\n                    }\n                    else { // spade, lower than queen\n                        break;\n                    }\n                }\n                if (highSpades.length) { // I have high spades\n                    return highSpades[highSpades.length - 1]; // play lowest high spade\n                }\n                else { // I don't have any high spades\n                    // play the highest card in the suit of the highest lowest card of its suit\n                    // (yes, you understood that)\n                    // algorithm:\n                    // look at the lowest card in each suit\n                    // which one of those is the highest?\n                    // what's the suit of that card?\n                    // play the highest card in that suit\n                    let currentSuit = validChoices[0].suit;\n                    /** suit of the highest lowest card of its suit */\n                    let sothlcois = currentSuit;\n                    let lowestValue = validChoices[0].value; // in that suit\n                    for (let i = 1; i < validChoices.length; ++i) {\n                        if (validChoices[i].suit !== currentSuit) { // moved into new suit\n                            currentSuit = validChoices[i].suit;\n                            if (validChoices[i].value // lowest value in this suit\n                                > lowestValue // found one higher\n                            ) {\n                                sothlcois = currentSuit;\n                                lowestValue = validChoices[i].value;\n                            }\n                        }\n                    }\n                    // now we know the suit of the highest lowest card of its suit\n                    // since we don't have any high spades, any card of this suit should be a valid choice\n                    // so we can pull it out of the hand (instead of the valid_choices)\n                    const cardsInSuit = this.gameHand.getHand(this.gameHand.getWhoseTurn()).getSuit(sothlcois);\n                    return cardsInSuit[cardsInSuit.length - 1];\n                }\n            }\n        }\n        else { // I lead\n            const nonHighSpades = validChoices.filter((card) => {\n                return (card.value < 12 || card.suit !== Card_1.default.SPADES);\n            });\n            if (nonHighSpades.length) {\n                // found something that's not high spade\n                // random (without high spades)\n                return nonHighSpades[Math.floor(Math.random() * nonHighSpades.length)];\n            }\n            // else only high spades available\n            return validChoices[0]; // play lowest high spade\n        }\n        /*\n                    let foundNonHighSpade = false;\n                    for (let i = 0; i < validChoices.length; --i) {\n                        if (validChoices[i].value < 12 || validChoices[i].suit !== Card.SPADES) {\n                            // found something that's not high spade\n                            foundNonHighSpade = true;\n                            break;\n                        }\n                    }\n                    if (! foundNonHighSpade) {  // only high spades available\n                        return validChoices[0];  // play lowest high spade\n                    }\n                    // random, but not high spade\n                    let lengthWOHighSpades = validChoices.length;\n                    let randomIndex;\n                    while (true) {\n                        randomIndex = Math.floor(Math.random() * lengthWOHighSpades);\n                        if (validChoices[randomIndex].value > 11 && validChoices[randomIndex].suit === Card.SPADES) {  // high spade\n                            // swap high spade into last spot\n                            // I stopped here and decided to use filter instead\n                            // TODO: can I get better performance if I don't use filter?\n                        }\n                    }\n                }\n                */\n    }\n    simPlayCard() {\n        // TODO: I don't know a good way to tune these numbers\n        // if shooting the moon is possible, higher probability of playing a random card\n        const myCardCount = this.gameHand.getHand(this.gameHand.getWhoseTurn()).length();\n        /** out of 10 */\n        const randomIfLessThan = this.gameHand.getShootMoonPossible()\n            // first trick play random, otherwise get gradually more random over the hand\n            ? ((myCardCount > 12) ? 10 : (myCardCount * -0.8 + 11.5))\n            // if shoot the moon not possible, low probability of random\n            : 2;\n        if (Math.random() * 10 < randomIfLessThan) {\n            const vc = this.gameHand.findValidChoices();\n            return vc[Math.floor(Math.random() * vc.length)];\n        }\n        else {\n            return this.staticPlayAI();\n        }\n    }\n    dynamicPlay() {\n        const validChoices = this.gameHand.findValidChoices();\n        if (validChoices.length === 1) {\n            return validChoices[0];\n        }\n        const scoreForEachVC = validChoices.map(() => { return 0; });\n        // console.log(\"score array should be all 0s, one for each valid\");\n        // console.log(scoreForEachVC);\n        const loopCount = Math.floor((AI.LEVEL / validChoices.length) / this.gameHand.getHand(this.gameHand.getWhoseTurn()).length()) + 1;\n        for (let i = loopCount; i > 0; --i) {\n            validChoices.forEach((card, index) => {\n                const sim = new GameHand_1.default(this.gameHand);\n                const simAI = new AI(sim, this.whoAmI);\n                sim.setHands(this.speculateHands(sim.getPassingDirection()));\n                // play the card we're checking now\n                sim.playCard(card);\n                do {\n                    while (sim.turnsLeftInTrick()) {\n                        sim.playCard(simAI.simPlayCard());\n                    }\n                    sim.endTrick();\n                    if (sim.getHand(0).length()) { // more tricks to play\n                        sim.resetTrick();\n                    }\n                } while (sim.getHand(0).length()); // until there are no more tricks left to play\n                sim.endHand();\n                scoreForEachVC[index] += sim.getScore(this.whoAmI);\n                // console.log(\"just added\", sim.getScore(this.whoAmI), \"now\", scoreForEachVC[index]);\n            }); // end valid choice loop\n        } // end loop according to AI.LEVEL\n        // simple min function\n        let indexOfMin = 0;\n        console.log(validChoices[0].str(), scoreForEachVC[0] / loopCount);\n        for (let i = 1; i < validChoices.length; ++i) {\n            if (scoreForEachVC[i] < scoreForEachVC[indexOfMin]) {\n                indexOfMin = i;\n            }\n            console.log(validChoices[i].str(), scoreForEachVC[i] / loopCount);\n        }\n        return validChoices[indexOfMin];\n    }\n}\n/** number of tricks to simulate */\nAI.LEVEL = 10000;\nexports.default = AI;\n//# sourceMappingURL=AI.js.map\n\n//# sourceURL=webpack:///./build/AI.js?");

/***/ }),

/***/ "./build/Card.js":
/*!***********************!*\
  !*** ./build/Card.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Card {\n    constructor(value, suit) {\n        if (value.hasOwnProperty(\"suit\")) {\n            // copy constructor\n            const card = value;\n            this.value = card.value;\n            this.suit = card.suit;\n        }\n        else {\n            this.value = value;\n            this.suit = suit;\n        }\n    }\n    /**\n     * binary search a sorted Card array for a card,\n     * return index, -1 if not found\n     * @param sortedArray\n     * @param card\n     * @param beginIndex\n     * @param endIndexPlus1\n     */\n    static find(sortedArray, card) {\n        let beginIndex = 0;\n        let endIndexPlus1 = sortedArray.length;\n        let looking = endIndexPlus1 >> 1; // middle\n        while (looking < endIndexPlus1) {\n            if (sortedArray[looking].value === card.value) {\n                return looking;\n            }\n            if (sortedArray[looking].value > card.value) {\n                endIndexPlus1 = looking;\n            }\n            else {\n                beginIndex = looking + 1;\n            }\n            looking = (beginIndex + endIndexPlus1) >> 1; // new middle\n        }\n        return -1;\n    }\n    str() {\n        let to_return;\n        switch (this.value) {\n            case 1:\n            case 14:\n                to_return = \"Ace of \";\n                break;\n            case 11:\n                to_return = \"Jack of \";\n                break;\n            case 12:\n                to_return = \"Queen of \";\n                break;\n            case 13:\n                to_return = \"King of \";\n                break;\n            default:\n                to_return = this.value.toString();\n                to_return += \" of \";\n        }\n        switch (this.suit) {\n            case Card.CLUBS:\n                to_return += \"Clubs\";\n                break;\n            case Card.DIAMONDS:\n                to_return += \"Diamonds\";\n                break;\n            case Card.SPADES:\n                to_return += \"Spades\";\n                break;\n            case Card.HEARTS:\n                to_return += \"Hearts\";\n                break;\n            default:\n                to_return += \"UNKNOWN SUIT\";\n        }\n        return to_return;\n    }\n    hash() {\n        return (this.value << 2) + this.suit;\n    }\n}\nCard.CLUBS = 0;\nCard.DIAMONDS = 1;\nCard.SPADES = 2;\nCard.HEARTS = 3;\nCard.SUIT_COUNT = 4;\nexports.default = Card;\n//# sourceMappingURL=Card.js.map\n\n//# sourceURL=webpack:///./build/Card.js?");

/***/ }),

/***/ "./build/CardGroup.js":
/*!****************************!*\
  !*** ./build/CardGroup.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; --i) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\n/** Card container\n *\n *  maintains cards in order by suit and then by value\n */\nclass CardGroup {\n    constructor(cardGroup) {\n        this.cards = [\n            [], [], [], [] // one for each suit\n        ];\n        if (cardGroup) {\n            // copy constructor\n            cardGroup.cards.forEach((suitArray, suitIndex) => {\n                suitArray.forEach((card) => {\n                    this.cards[suitIndex].push(new Card_1.default(card));\n                });\n            });\n        }\n    }\n    /**\n     * the number of cards in given suit\n     *  - if no suit given, the number of cards in the CardGroup\n     * @param suit\n     */\n    length(suit = -1) {\n        if (suit === -1) {\n            return this.cards[0].length + this.cards[1].length + this.cards[2].length + this.cards[3].length;\n        }\n        return this.cards[suit].length;\n    }\n    /** convert fullIndex, which is the index to the CardGroup,\n     *  to a suit and index within that suit\n     */\n    getSuitAndIndex(fullIndex) {\n        let suit = 0;\n        while (suit < 4 && fullIndex >= this.cards[suit].length) {\n            fullIndex -= this.cards[suit].length;\n            suit += 1;\n        }\n        if (suit < 4) {\n            return {\n                suit: suit,\n                index: fullIndex\n            };\n        }\n        return null;\n    }\n    at(index) {\n        const suitAndIndex = this.getSuitAndIndex(index);\n        if (suitAndIndex)\n            return this.cards[suitAndIndex.suit][suitAndIndex.index];\n        return null;\n    }\n    forEach(callback) {\n        let index = 0;\n        this.cards.forEach((suit) => {\n            suit.forEach((card) => {\n                callback(card, index);\n                ++index;\n            });\n        });\n    }\n    /**\n     * returns index, -1 if not present\n     * @param card\n     */\n    find(card) {\n        let indexToReturn = Card_1.default.find(this.cards[card.suit], card);\n        if (indexToReturn === -1) {\n            return -1;\n        }\n        for (let suit = 0; suit < card.suit; ++suit) {\n            indexToReturn += this.cards[suit].length;\n        }\n        return indexToReturn;\n    }\n    remove(cardOrIndex) {\n        let indexInSuitArray, arrayToRemoveFrom;\n        if (cardOrIndex.hasOwnProperty(\"suit\")) {\n            const card = cardOrIndex;\n            arrayToRemoveFrom = this.cards[card.suit];\n            indexInSuitArray = Card_1.default.find(arrayToRemoveFrom, card);\n            if (indexInSuitArray === -1) {\n                return;\n            }\n        }\n        else { // cardOrIndex is index\n            const suitAndIndex = this.getSuitAndIndex(cardOrIndex);\n            if (!suitAndIndex) {\n                return;\n            }\n            arrayToRemoveFrom = this.cards[suitAndIndex.suit];\n            indexInSuitArray = suitAndIndex.index;\n        }\n        arrayToRemoveFrom.splice(indexInSuitArray, 1);\n    }\n    insert(card) {\n        const arrayToInsertTo = this.cards[card.suit];\n        let i = 0;\n        for (; i < arrayToInsertTo.length; ++i) {\n            if (arrayToInsertTo[i].value > card.value) {\n                break;\n            }\n        }\n        arrayToInsertTo.splice(i, 0, card);\n    }\n    /** removes all the cards from this CardGroup */\n    clear() {\n        this.cards.forEach((suitArray) => {\n            suitArray.length = 0;\n        });\n    }\n    /**\n     * fill with 52 cards\n     */\n    fill() {\n        this.cards.forEach((suitArray, suitNumber) => {\n            suitArray.length = 0;\n            for (let i = 2; i < 15; ++i) {\n                suitArray.push(new Card_1.default(i, suitNumber));\n            }\n        });\n    }\n    /** choose a random Card out of the CardGroup,\n     *  remove it, and return it\n     */\n    dealOne() {\n        const index = Math.floor(Math.random() * this.length());\n        const toReturn = this.at(index);\n        this.remove(index);\n        // @ts-ignore trust me, it will not be null\n        return toReturn;\n    }\n    /** from hand of 13 cards\n     *\n     *  precondition: `length() === 13`\n     */\n    pickRandom(n) {\n        const toReturn = [];\n        const indexes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        shuffleArray(indexes);\n        for (let i = 0; i < n; ++i) {\n            toReturn.push(this.at(indexes[i]));\n        }\n        return toReturn;\n    }\n    /** returns a reference to an array of the cards in one suit\n     */\n    getSuit(suit) {\n        return this.cards[suit];\n    }\n    /** returns an array with all the cards in this CardGroup */\n    slice() {\n        return this.cards[0].concat(this.cards[1], this.cards[2], this.cards[3]);\n    }\n}\nexports.default = CardGroup;\n//# sourceMappingURL=CardGroup.js.map\n\n//# sourceURL=webpack:///./build/CardGroup.js?");

/***/ }),

/***/ "./build/GameHand.js":
/*!***************************!*\
  !*** ./build/GameHand.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CardGroup_1 = __importDefault(__webpack_require__(/*! ./CardGroup */ \"./build/CardGroup.js\"));\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nconst nullCard = new Card_1.default(0, 0);\n/**\n * each hand, call these in this order:\n * ```\n * resetHand();\n * dealHands();\n * pass(fromPlayer, toPlayer, passedCards);\n * receivePassedCards();  // TODO: return which cards (for UI)\n * resetTrick();\n * playCard(card);  // TODO: return hearts broken (for UI)\n * endTrick();  // TODO: returns who took the trick? (for UI)\n * endHand();  // returns who shot the moon\n * ```\n */\nclass GameHand {\n    constructor(gameHand) {\n        this.hands = [new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default()];\n        this.scores = [0, 0, 0, 0];\n        this.passingDirection = 0;\n        this.passedCardsToPlayer = [[], [], [], []]; // first index is player passed to\n        this.passCount = 0;\n        // trick\n        this.playedCards = [nullCard, nullCard, nullCard, nullCard];\n        this.playedCardCount = 0;\n        this.trickLeader = 0;\n        this.whoseTurn = 0;\n        this.heartsBroken = false;\n        this.pointsPlayedThisTrick = false;\n        /** updates in `endTrick` */\n        this.trickHistory = [];\n        this.shootMoonPossible = true;\n        this.observerList = [];\n        if (gameHand) {\n            // copy constructor\n            this.hands[0] = new CardGroup_1.default(gameHand.hands[0]);\n            this.hands[1] = new CardGroup_1.default(gameHand.hands[1]);\n            this.hands[2] = new CardGroup_1.default(gameHand.hands[2]);\n            this.hands[3] = new CardGroup_1.default(gameHand.hands[3]);\n            this.scores = gameHand.scores.map(x => x);\n            this.passingDirection = gameHand.passingDirection;\n            for (let player = 0; player < 4; ++player) {\n                this.passedCardsToPlayer[player].length = 0;\n                gameHand.passedCardsToPlayer[player].forEach((card) => {\n                    this.passedCardsToPlayer[player].push(new Card_1.default(card));\n                });\n            }\n            this.passCount = gameHand.passCount;\n            this.playedCards[0] = new Card_1.default(gameHand.playedCards[0]);\n            this.playedCards[1] = new Card_1.default(gameHand.playedCards[1]);\n            this.playedCards[2] = new Card_1.default(gameHand.playedCards[2]);\n            this.playedCards[3] = new Card_1.default(gameHand.playedCards[3]);\n            this.playedCardCount = gameHand.playedCardCount;\n            this.trickLeader = gameHand.trickLeader;\n            this.whoseTurn = gameHand.whoseTurn;\n            this.heartsBroken = gameHand.heartsBroken;\n            this.pointsPlayedThisTrick = gameHand.pointsPlayedThisTrick;\n            this.trickHistory = gameHand.trickHistory.map((tr) => {\n                return {\n                    cards: tr.cards.map((card) => new Card_1.default(card)),\n                    whoWon: tr.whoWon\n                };\n            });\n            this.shootMoonPossible = gameHand.shootMoonPossible;\n            // don't copy observer list\n        }\n    }\n    registerObserver(ob) {\n        this.observerList.push(ob);\n    }\n    getWhoseTurn() {\n        return this.whoseTurn;\n    }\n    getHand(player) {\n        return this.hands[player];\n    }\n    getScore(player) {\n        return this.scores[player];\n    }\n    getPassingDirection() {\n        return this.passingDirection;\n    }\n    turnsLeftInTrick() {\n        return 4 - this.playedCardCount;\n    }\n    heartsIsBroken() {\n        return this.heartsBroken;\n    }\n    getPassCount() {\n        return this.passCount;\n    }\n    getPlayedCards() {\n        return this.playedCards;\n    }\n    getPlayedCardCount() {\n        return this.playedCardCount;\n    }\n    /** changes with `GameHand.endTrick()`\n     *\n     *  Between `endTrick` and `resetTrick`, this returns the same cards as `getPlayedCards`\n     */\n    getPreviousTrick() {\n        const l = this.trickHistory.length;\n        return l ? this.trickHistory[l - 1] : {\n            cards: [],\n            whoWon: 0\n        };\n    }\n    getTrickLeader() {\n        return this.trickLeader;\n    }\n    getPassedCardsToPlayer(player) {\n        return this.passedCardsToPlayer[player];\n    }\n    getShootMoonPossible() {\n        return this.shootMoonPossible;\n    }\n    /**\n     * to be called on keeper hand to say we're done passing\n     */\n    setPassed() {\n        this.passCount = 4;\n    }\n    /** to be called with speculated hands in AI simulation */\n    setHands(hands) {\n        this.hands = hands;\n    }\n    resetHand(passingDirection) {\n        this.passingDirection = passingDirection;\n        for (let i = 0; i < 4; ++i) {\n            this.hands[i].clear();\n            this.scores[i] = 0;\n            this.passedCardsToPlayer[i].length = 0;\n        }\n        this.passCount = 0;\n        this.heartsBroken = false;\n        this.trickHistory.length = 0;\n        this.shootMoonPossible = true;\n        this.observerList.forEach((ob) => { ob.resetHand(); });\n    }\n    dealHands() {\n        const deck = new CardGroup_1.default();\n        deck.fill();\n        while (deck.length()) {\n            for (let i = 0; i < 4; ++i) {\n                const dealt = deck.dealOne();\n                this.hands[i].insert(dealt);\n                if (dealt.value === 2 && dealt.suit === Card_1.default.CLUBS) {\n                    this.whoseTurn = i;\n                }\n            }\n        }\n        this.observerList.forEach((ob) => { ob.dealHands(); });\n    }\n    pass(fromPlayer, toPlayer, cards) {\n        cards.forEach((card) => {\n            this.passedCardsToPlayer[toPlayer].push(card);\n            this.hands[fromPlayer].remove(card);\n        });\n        ++this.passCount;\n        this.observerList.forEach((ob) => { ob.pass(fromPlayer, toPlayer, cards); });\n    }\n    receivePassedCards() {\n        for (let playerIndex = 0; playerIndex < 4; ++playerIndex) {\n            this.passedCardsToPlayer[playerIndex].forEach((card) => {\n                this.hands[playerIndex].insert(card);\n                if (card.value === 2 && card.suit === Card_1.default.CLUBS) {\n                    this.whoseTurn = playerIndex;\n                }\n            });\n        }\n        this.observerList.forEach((ob) => { ob.receivePassedCards(); });\n    }\n    resetTrick() {\n        this.playedCards = [nullCard, nullCard, nullCard, nullCard];\n        this.playedCardCount = 0;\n        this.trickLeader = this.whoseTurn;\n        this.pointsPlayedThisTrick = false;\n        this.observerList.forEach((ob) => { ob.resetTrick(); });\n    }\n    takesLead(card) {\n        return (card.suit === this.playedCards[this.trickLeader].suit &&\n            card.value > this.playedCards[this.trickLeader].value);\n    }\n    playCard(card) {\n        // console.log(\"playing card on turn:\", this.whoseTurn);\n        this.hands[this.whoseTurn].remove(card);\n        this.playedCards[this.whoseTurn] = card;\n        // console.log(\"added card to playedCards:\", this.playedCards);\n        ++this.playedCardCount;\n        if (this.takesLead(card)) {\n            this.trickLeader = this.whoseTurn;\n        }\n        let showingOnlyHearts = false;\n        if (card.suit === Card_1.default.HEARTS) {\n            if (this.playedCardCount === 1 && !this.heartsBroken) {\n                showingOnlyHearts = true;\n            }\n            this.heartsBroken = true; // TODO: alternate rule q of spades breaks hearts?\n        }\n        if (this.pointsFor(card)) {\n            this.pointsPlayedThisTrick = true;\n        }\n        // give observer who played the card\n        const byPlayer = this.whoseTurn;\n        // see if it's still possible to shoot the moon\n        if (this.shootMoonPossible) {\n            if (this.pointsPlayedThisTrick) {\n                let nonZeroScore = -1;\n                for (let player = 0; player < 4; ++player) {\n                    if (this.getScore(player)) {\n                        nonZeroScore = player;\n                        break;\n                    }\n                }\n                if (nonZeroScore !== -1) {\n                    // see whether this player has played yet this trick\n                    let thisPlayerPLayed = false;\n                    let goingThroughTurns = (byPlayer + 5 - this.getPlayedCardCount()) % 4; // first turn this trick\n                    for (let turn = this.getPlayedCardCount(); turn > 0; --turn) {\n                        if (goingThroughTurns === nonZeroScore) {\n                            thisPlayerPLayed = true;\n                            break;\n                        }\n                        goingThroughTurns = (goingThroughTurns + 1) % 4;\n                    }\n                    if (thisPlayerPLayed) {\n                        if (nonZeroScore !== this.getTrickLeader()) {\n                            this.shootMoonPossible = false;\n                            // for testing\n                            // console.log(\"INFO: this is the point when it becomes impossible for anyone to shoot the moon\");\n                        }\n                    }\n                }\n            }\n        }\n        this.whoseTurn = (this.whoseTurn + 1) % 4;\n        this.observerList.forEach((ob) => { ob.seeCardPlayed(card, byPlayer, showingOnlyHearts); });\n    }\n    pointsFor(card) {\n        return (card.suit === Card_1.default.HEARTS) ? 1 : ((card.value === 12 && card.suit === Card_1.default.SPADES) ? 13 : 0);\n    }\n    endTrick() {\n        this.playedCards.forEach((card) => {\n            this.scores[this.trickLeader] += this.pointsFor(card);\n        });\n        this.whoseTurn = this.trickLeader;\n        this.trickHistory.push({\n            cards: this.playedCards.slice(),\n            whoWon: this.trickLeader\n        });\n    }\n    /**\n     * returns who shot the moon, -1 if no one\n     */\n    endHand() {\n        // need the played cards to go away so gui doesn't try to draw them\n        this.playedCards = [nullCard, nullCard, nullCard, nullCard];\n        this.playedCardCount = 0;\n        for (let winPlayer = 0; winPlayer < 4; ++winPlayer) { // check for shoot the moon\n            if (this.scores[winPlayer] === 26) {\n                this.scores[winPlayer] = 0;\n                for (let losePlayer = 0; losePlayer < 4; ++losePlayer) {\n                    if (losePlayer !== winPlayer) {\n                        this.scores[losePlayer] = 26;\n                    }\n                }\n                return winPlayer;\n            }\n            else if (this.scores[winPlayer] > 0) { // 1 to 25 points\n                return -1;\n            }\n        }\n        alert(\"this should never happen, invalid scores\");\n        console.log(\"this should never happen, invalid scores\");\n        return -2;\n    }\n    // rules of the game\n    findValidChoices() {\n        const hand = this.hands[this.whoseTurn];\n        if (hand.length() === 13) { // first trick\n            if (this.playedCardCount === 0) { // first player\n                return [new Card_1.default(2, Card_1.default.CLUBS)];\n            }\n            // not first player\n            if (hand.length(Card_1.default.CLUBS)) {\n                return hand.getSuit(Card_1.default.CLUBS);\n            }\n            else { // no clubs\n                const validChoices = [];\n                hand.forEach((card) => {\n                    if (!this.pointsFor(card)) {\n                        validChoices.push(card);\n                    }\n                });\n                if (validChoices.length) {\n                    return validChoices;\n                }\n                // only points in hand\n                return hand.slice();\n            }\n        }\n        else { // not first trick\n            if (this.playedCardCount === 0) { // leading trick\n                if (this.heartsBroken) {\n                    return hand.slice();\n                }\n                // hearts not broken\n                if (hand.length(Card_1.default.HEARTS) === hand.length()) { // only hearts in hand\n                    return hand.slice();\n                }\n                // non-hearts in hand, play anything not hearts\n                const validChoices = [];\n                hand.forEach((card) => {\n                    if (card.suit !== Card_1.default.HEARTS) {\n                        validChoices.push(card);\n                    }\n                });\n                return validChoices;\n            }\n            else { // not leading trick\n                if (hand.length(this.playedCards[this.trickLeader].suit)) { // have suit that is lead\n                    return hand.getSuit(this.playedCards[this.trickLeader].suit);\n                }\n                // don't have matching suit\n                return hand.slice();\n            }\n        }\n    }\n}\nexports.default = GameHand;\n//# sourceMappingURL=GameHand.js.map\n\n//# sourceURL=webpack:///./build/GameHand.js?");

/***/ }),

/***/ "./build/worker.js":
/*!*************************!*\
  !*** ./build/worker.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AI_1 = __importDefault(__webpack_require__(/*! ./AI */ \"./build/AI.js\"));\n// when I follow examples for web workers online, typescript complains\n// so I found this solution:\n// https://stackoverflow.com/questions/50402004/error-ts2554-expected-2-3-arguments-but-got-1\nconst ctx = self;\nctx.addEventListener('message', (message) => {\n    console.log('in webworker', message);\n    if (message.data.length) {\n        // AI array\n        const ai1 = new AI_1.default(message.data[1]);\n        const ai2 = new AI_1.default(message.data[2]);\n        const ai3 = new AI_1.default(message.data[3]);\n        // console.log(ai1.staticPlayAI());\n        // I don't think i need these\n        // all it does is give me information for speculating hands\n        // I only speculate hands once per simulation\n        // I already have the information I need to speculate that one time\n        // ai1.observeSelf();\n        // ai2.observeSelf();\n        // ai3.observeSelf();\n        const ai1Cards = ai1.choosePassingCards();\n        const ai2Cards = ai2.choosePassingCards();\n        const ai3Cards = ai3.choosePassingCards();\n        ctx.postMessage([null, ai1Cards, ai2Cards, ai3Cards]);\n    }\n    else {\n        // single AI\n        // pick a card to play\n        const ai = new AI_1.default(message.data);\n        ai.observeSelf();\n        ctx.postMessage(ai.dynamicPlay());\n    }\n});\n//# sourceMappingURL=worker.js.map\n\n//# sourceURL=webpack:///./build/worker.js?");

/***/ })

/******/ });