/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/hearts.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/AI.js":
/*!*********************!*\
  !*** ./build/AI.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CardGroup_1 = __importDefault(__webpack_require__(/*! ./CardGroup */ \"./build/CardGroup.js\"));\nconst GameHand_1 = __importDefault(__webpack_require__(/*! ./GameHand */ \"./build/GameHand.js\"));\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nclass AI {\n    constructor(gameHand, whoAmI) {\n        this.unknownCards = new CardGroup_1.default();\n        /** example:\n         *  `playerSeenVoidInSuits[2][Card.CLUBS]`\n         *  is whether player 2 has shown that they don't have any clubs */\n        this.playerSeenVoidInSuits = [];\n        /** and not played yet, removed from here when they are seen played */\n        this.cardsIPassed = [];\n        if (gameHand.hasOwnProperty(\"whoAmI\")) {\n            // copy constructor\n            const ai = gameHand;\n            this.unknownCards = new CardGroup_1.default(ai.unknownCards);\n            this.playerSeenVoidInSuits = ai.playerSeenVoidInSuits; // shallow copy, don't think I need deep copy\n            this.cardsIPassed.length = 0;\n            ai.cardsIPassed.forEach((card) => {\n                this.cardsIPassed.push(new Card_1.default(card));\n            });\n            this.gameHand = new GameHand_1.default(ai.gameHand);\n            this.whoAmI = ai.whoAmI;\n        }\n        else {\n            this.gameHand = gameHand;\n            this.whoAmI = whoAmI;\n            this.resetHand(); // just to be safe\n        }\n    }\n    /** to be called in worker where observerList has been removed */\n    observeSelf() {\n        this.gameHand.registerObserver(this);\n        // TODO: find out if I need this... I don't think I do\n    }\n    setHand(hand) {\n        this.gameHand = hand;\n    }\n    choosePassingCards() {\n        const t0 = performance.now(); // time test\n        const hand = this.gameHand.getHand(this.whoAmI);\n        const scoresForEachCombination = new Array(286).fill(0);\n        const cardsForEachCombination = new Array(286).fill([]);\n        let scoreIndex = 0;\n        for (let i = 0; i < 11; ++i) {\n            for (let j = i + 1; j < 12; ++j) {\n                for (let k = j + 1; k < 13; ++k) {\n                    const cards = [hand.at(i), hand.at(j), hand.at(k)];\n                    cardsForEachCombination[scoreIndex] = cards;\n                    const loopCount = Math.floor(AI.LEVEL / (286 * 2)) + 1;\n                    for (let simNum = loopCount; simNum > 0; --simNum) {\n                        const sim = new GameHand_1.default(this.gameHand);\n                        const simAIS = [\n                            new AI(sim, 0),\n                            new AI(sim, 1),\n                            new AI(sim, 2),\n                            new AI(sim, 3)\n                        ];\n                        sim.setHands(this.speculateHands(sim.getPassingDirection()));\n                        // passing\n                        for (let playerToPass = 0; playerToPass < 4; ++playerToPass) {\n                            if (playerToPass === this.whoAmI) {\n                                sim.pass(playerToPass, (playerToPass + this.gameHand.getPassingDirection()) % 4, cards);\n                            }\n                            else { // not the player who is simulating\n                                sim.pass(playerToPass, (playerToPass + this.gameHand.getPassingDirection()) % 4, sim.getHand(playerToPass).pickRandom(3));\n                            }\n                        }\n                        sim.receivePassedCards();\n                        // playing\n                        for (let tricks = 13; tricks > 0; --tricks) {\n                            sim.resetTrick();\n                            while (sim.turnsLeftInTrick()) {\n                                sim.playCard(simAIS[sim.getWhoseTurn()].simPlayCard());\n                            }\n                            sim.endTrick();\n                        }\n                        sim.endHand();\n                        // done playing\n                        scoresForEachCombination[scoreIndex] += sim.getScore(this.whoAmI);\n                    }\n                    ++scoreIndex;\n                }\n            }\n        }\n        let bestIndex = 0;\n        for (scoreIndex = 0; scoreIndex < 286; ++scoreIndex) {\n            if (scoresForEachCombination[scoreIndex] < scoresForEachCombination[bestIndex]) {\n                bestIndex = scoreIndex;\n            }\n        }\n        const t1 = performance.now();\n        // for testing\n        console.log(\"player \" + this.whoAmI + \" had:\");\n        hand.forEach((card) => {\n            console.log(card.str());\n        });\n        console.log(\"and chose to pass:\");\n        console.log(cardsForEachCombination[bestIndex]);\n        console.log(\"time: \" + (t1 - t0));\n        return cardsForEachCombination[bestIndex];\n    }\n    speculateHands(passingDirection) {\n        const speculatedHands = [\n            new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default()\n        ];\n        const spaceRemainingIn = [\n            this.gameHand.getHand(0).length(),\n            this.gameHand.getHand(1).length(),\n            this.gameHand.getHand(2).length(),\n            this.gameHand.getHand(3).length()\n        ];\n        // I know my own hand\n        spaceRemainingIn[this.whoAmI] = 0;\n        const whomIPassedTo = (this.whoAmI + passingDirection) % 4;\n        spaceRemainingIn[whomIPassedTo] -= this.cardsIPassed.length;\n        function nonFullHands(player) { return spaceRemainingIn[player] > 0; }\n        ;\n        // testing nonFullHands\n        // console.log(\"nonFullHands:\");\n        // console.log(0, nonFullHands(0));\n        // console.log(1, nonFullHands(1));\n        // console.log(2, nonFullHands(2));\n        // console.log(3, nonFullHands(3));\n        /** first index is suit, second is player, excludes the player speculating */\n        const handsThatAllowSuit = [];\n        for (let suit = 0; suit < 4; ++suit) {\n            handsThatAllowSuit.push([\n                (!(this.playerSeenVoidInSuits[0][suit])) && this.whoAmI !== 0,\n                (!(this.playerSeenVoidInSuits[1][suit])) && this.whoAmI !== 1,\n                (!(this.playerSeenVoidInSuits[2][suit])) && this.whoAmI !== 2,\n                (!(this.playerSeenVoidInSuits[3][suit])) && this.whoAmI !== 3\n            ]);\n        }\n        // console.log(\"handsThatAllowSuit:\");\n        // console.log(handsThatAllowSuit);\n        // console.log(\"unknown length\", this.unknownCards.length());\n        // this.unknownCards.forEach((card) => { console.log(card.str()); });\n        const allowSuitAndNonFull = []; // intersection of non-full-hands with hands that allow this suit\n        this.unknownCards.forEach((thisCard) => {\n            // console.log(\"trying to find a place for \", thisCard.str());\n            allowSuitAndNonFull.length = 0;\n            handsThatAllowSuit[thisCard.suit].forEach((allowThisSuit, player) => {\n                if (allowThisSuit && nonFullHands(player)) {\n                    allowSuitAndNonFull.push(player);\n                    // console.log(\"allowSuitAndNonFull:\", allowSuitAndNonFull);\n                }\n            });\n            if (allowSuitAndNonFull.length) {\n                const receiver = allowSuitAndNonFull[Math.floor(Math.random() * allowSuitAndNonFull.length)];\n                speculatedHands[receiver].insert(thisCard);\n                --spaceRemainingIn[receiver];\n            }\n            else { // there are no hands left that allow this suit and have space for this card\n                // console.log(\"couldn't find a place for it in one step (0 swaps)\");\n                // so we have to do some swapping\n                // find which suits are allowed in non-full hands\n                const suitsAllowedInNonFull = [false, false, false, false];\n                for (let player = 0; player < 4; ++player) {\n                    if (nonFullHands(player)) {\n                        for (let suit = 0; suit < 4; ++suit) {\n                            if (handsThatAllowSuit[suit][player]) {\n                                suitsAllowedInNonFull[suit] = true;\n                            }\n                        }\n                    }\n                }\n                // find possible cards to swap (out of those suits)\n                const possibleCards = [];\n                const fromPlayer = [];\n                // go through the hands that \"this card\" is allowed in\n                handsThatAllowSuit[thisCard.suit].forEach((allowed, player) => {\n                    if (allowed) {\n                        // go through the cards in this hand\n                        speculatedHands[player].forEach((card) => {\n                            // can this card go in a non-full hand?\n                            if (suitsAllowedInNonFull[card.suit]) {\n                                possibleCards.push(card);\n                                fromPlayer.push(player);\n                            }\n                        });\n                    }\n                });\n                if (possibleCards.length) {\n                    // do the swap\n                    const indexToSwap = Math.floor(Math.random() * possibleCards.length);\n                    /** intersection of non_full and allow swap suit */\n                    const allowSSANF = [];\n                    handsThatAllowSuit[possibleCards[indexToSwap].suit].forEach((allowed, player) => {\n                        if (allowed && nonFullHands(player)) {\n                            allowSSANF.push(player);\n                        }\n                    });\n                    // assert allowSSANF size > 0  // TODO: remove (or set up debugging)\n                    if (allowSSANF.length === 0) {\n                        console.log(\"ERROR: assertion fail, single swap, no place to put swap card\");\n                    }\n                    const receiver = allowSSANF[Math.floor(Math.random() * allowSSANF.length)];\n                    speculatedHands[receiver].insert(possibleCards[indexToSwap]);\n                    speculatedHands[fromPlayer[indexToSwap]].remove(possibleCards[indexToSwap]);\n                    // and this card in the space that was made for it\n                    speculatedHands[fromPlayer[indexToSwap]].insert(thisCard);\n                    // only the size of the non-full hand changed\n                    --spaceRemainingIn[receiver];\n                }\n                else { // no single swap possible, double swap is needed\n                    // assert: double swap is possible\n                    /* questionable assertion:\n                        There is a 3rd hand that is not involved in the previously used hands in this algorithm.\n                        One hand is full and is the only one that allows  thisCard\n                        A second hand is the only one not full and doesn't allow thisCard or any card in the first hand.\n                        The 3rd hand is full and must allow some suit that is in the first hand\n                                             and must have some suit that is allowed in the second hand. */\n                    const fullAndAllows = handsThatAllowSuit[thisCard.suit].indexOf(true); // \"1st hand\"\n                    let nonFull = 0; // \"2nd hand\"\n                    for (let player = 0; player < 4; ++player) {\n                        if (nonFullHands(player)) {\n                            nonFull = player;\n                            break;\n                        }\n                    }\n                    let thirdHand = 0;\n                    while ((thirdHand === fullAndAllows) ||\n                        (thirdHand === this.whoAmI) ||\n                        (thirdHand === nonFull)) {\n                        ++thirdHand;\n                    }\n                    // debugging assertions  // TODO: remove\n                    if (handsThatAllowSuit[thisCard.suit].filter(x => x).length !== 1) { // count 'true'\n                        console.log(\"ERROR: big assertion was wrong, hands that allow this suit != 1\"); // !\n                    }\n                    // also, number of non full hands was 1\n                    // go through third hand and find cards allowed in non-full hand\n                    const secondSwapPossibilities = [];\n                    speculatedHands[thirdHand].forEach((card) => {\n                        if (suitsAllowedInNonFull[card.suit]) {\n                            secondSwapPossibilities.push(card);\n                        }\n                    });\n                    // another of the debugging assertions  // TODO: remove\n                    if (secondSwapPossibilities.length === 0) {\n                        console.log(\"ERROR: big assertion was wrong, no cards to move from 3rd to 2nd\");\n                    }\n                    // move one of those cards to the non-full hand\n                    const secondSwap = secondSwapPossibilities[Math.floor(Math.random() *\n                        secondSwapPossibilities.length)];\n                    speculatedHands[nonFull].insert(secondSwap);\n                    speculatedHands[thirdHand].remove(secondSwap);\n                    --spaceRemainingIn[nonFull];\n                    // find cards that can be moved from first hand to third hand\n                    // possibleCards is already declared from way before and is empty\n                    speculatedHands[fullAndAllows].forEach((card) => {\n                        if (!(this.playerSeenVoidInSuits[thirdHand][card.suit])) {\n                            possibleCards.push(card);\n                        }\n                    });\n                    // another of the debugging assertions  // TODO: remove\n                    if (possibleCards.length === 0) {\n                        console.log(\"ERROR: big assertion was wrong, no cards to move from 1st to 3rd\");\n                    }\n                    // move one of those cards to the third hand\n                    const firstLevelSwap = possibleCards[Math.floor(Math.random() *\n                        possibleCards.length)];\n                    speculatedHands[thirdHand].insert(firstLevelSwap);\n                    speculatedHands[fullAndAllows].remove(firstLevelSwap);\n                    // so now it's not full and has space for this card\n                    // (it will be full right after inserting this card, so don't change space remaining)\n                    // Now, finally, we can get rid of this card\n                    speculatedHands[fullAndAllows].insert(thisCard);\n                } // done with double swap\n            } // done with any swapping\n        }); // next card\n        // put in the cards that I already knew\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            speculatedHands[this.whoAmI].insert(card);\n        });\n        this.cardsIPassed.forEach((card) => {\n            speculatedHands[whomIPassedTo].insert(card);\n        });\n        return speculatedHands;\n    }\n    resetHand() {\n        this.unknownCards.fill();\n        this.cardsIPassed.length = 0;\n        this.playerSeenVoidInSuits = [\n            [false, false, false, false],\n            [false, false, false, false],\n            [false, false, false, false],\n            [false, false, false, false]\n        ];\n    }\n    dealHands() {\n        console.log(\"seeing my dealt hand:\", this.whoAmI);\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            this.unknownCards.remove(card);\n            console.log(card.str());\n        });\n    }\n    pass(fromPlayer, _toPlayer, cards) {\n        if (fromPlayer === this.whoAmI) {\n            this.cardsIPassed = cards.slice();\n        }\n    }\n    receivePassedCards() {\n        console.log(\"seeing my cards after passing\", this.whoAmI);\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            this.unknownCards.remove(card);\n            console.log(card.str());\n        });\n    }\n    resetTrick() {\n    }\n    seeCardPlayed(card, byPlayer, showingOnlyHearts = false) {\n        // console.log(\"seeing a card played\", this.whoAmI);\n        // console.log(card.str());\n        // console.log(\"see card unknown length before:\", this.unknownCards.length());\n        this.unknownCards.remove(card);\n        // console.log(\"just removed because saw it played\");\n        // console.log(\"see card unknown length after:\", this.unknownCards.length());\n        // remove from passed cards\n        let indexInPassed = -1;\n        this.cardsIPassed.forEach((passedCard, index) => {\n            if (card.value === passedCard.value && card.suit === passedCard.suit) {\n                indexInPassed = index;\n            }\n        });\n        if (indexInPassed !== -1) {\n            this.cardsIPassed.splice(indexInPassed, 1);\n        }\n        // is player showing they have none of a suit?\n        const leadSuit = this.gameHand.getPlayedCards()[this.gameHand.getTrickLeader()].suit;\n        if (card.suit !== leadSuit) {\n            this.playerSeenVoidInSuits[byPlayer][leadSuit] = true;\n        }\n        // showing that they only have hearts?\n        if (showingOnlyHearts) {\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.CLUBS] = true;\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.DIAMONDS] = true;\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.SPADES] = true;\n        }\n    }\n    staticPlayAI() {\n        const validChoices = this.gameHand.findValidChoices();\n        if (this.gameHand.getPlayedCardCount() > 0) { // I'm not leading the trick\n            const leadCard = this.gameHand.getPlayedCards()[this.gameHand.getTrickLeader()];\n            if (validChoices[0].suit === leadCard.suit) { // I have to follow suit\n                if (validChoices[0].value < leadCard.value) { // I can play under, avoid taking it\n                    // find highest card I can avoid taking it with\n                    for (let i = validChoices.length - 1; i >= 0; --i) {\n                        if (validChoices[i].value < leadCard.value) { // this is highest card I can avoid taking it with\n                            // Q of Spades instead of K of Spades\n                            if (validChoices[i].value === 13 && // king\n                                validChoices[i].suit === Card_1.default.SPADES && // of spades\n                                i > 0 && // I have a lower spade\n                                validChoices[i - 1].value === 12 // and it's the queen\n                            ) {\n                                return validChoices[i - 1];\n                            }\n                            else { // not k and q of spades\n                                return validChoices[i]; // highest card I can avoid taking it with\n                            }\n                        }\n                    }\n                    console.log(\"ERROR: should never get here\");\n                    return validChoices[0]; // just so compiler doesn't complain about not returning a card\n                }\n                else { // I can't play under\n                    if (this.gameHand.getPlayedCardCount() < 3) { // someone else will play after me\n                        if (leadCard.suit === Card_1.default.SPADES) { // spades\n                            if (validChoices[0].value === 12 && // queen\n                                validChoices.length > 1) { // and I have something else\n                                return validChoices[1];\n                            }\n                            else { // not queen or I don't have anything else\n                                return validChoices[0];\n                            }\n                        }\n                        else { // not spades\n                            return validChoices[0];\n                        }\n                    }\n                    else { // no one else plays after me\n                        const highestCard = validChoices[validChoices.length - 1];\n                        if (leadCard.suit === Card_1.default.SPADES) { // spades\n                            if (highestCard.value === 12 && // queen\n                                validChoices.length > 1 // and I have something else\n                            ) {\n                                return validChoices[validChoices.length - 2]; // highest except queen\n                            }\n                            else { // not queen or I don't have anything else\n                                return highestCard;\n                            }\n                        }\n                        else { // not spades\n                            return highestCard;\n                        }\n                    }\n                }\n            }\n            else { // don't have to follow suit (and not leading)\n                // GET RID OF THE QUEEN!!\n                // (play lowest of high spades)\n                const highSpades = []; // ordered from highest to lowest\n                for (let i = validChoices.length - 1; i >= 0; --i) {\n                    if (validChoices[i].suit !== Card_1.default.SPADES) {\n                        continue;\n                    }\n                    if (validChoices[i].value > 11) { // higher than jack\n                        highSpades.push(validChoices[i]);\n                    }\n                    else { // spade, lower than queen\n                        break;\n                    }\n                }\n                if (highSpades.length) { // I have high spades\n                    return highSpades[highSpades.length - 1]; // play lowest high spade\n                }\n                else { // I don't have any high spades\n                    // play the highest card in the suit of the highest lowest card of its suit\n                    // (yes, you understood that)\n                    // algorithm:\n                    // look at the lowest card in each suit\n                    // which one of those is the highest?\n                    // what's the suit of that card?\n                    // play the highest card in that suit\n                    let currentSuit = validChoices[0].suit;\n                    /** suit of the highest lowest card of its suit */\n                    let sothlcois = currentSuit;\n                    let lowestValue = validChoices[0].value; // in that suit\n                    for (let i = 1; i < validChoices.length; ++i) {\n                        if (validChoices[i].suit !== currentSuit) { // moved into new suit\n                            currentSuit = validChoices[i].suit;\n                            if (validChoices[i].value // lowest value in this suit\n                                > lowestValue // found one higher\n                            ) {\n                                sothlcois = currentSuit;\n                                lowestValue = validChoices[i].value;\n                            }\n                        }\n                    }\n                    // now we know the suit of the highest lowest card of its suit\n                    // since we don't have any high spades, any card of this suit should be a valid choice\n                    // so we can pull it out of the hand (instead of the valid_choices)\n                    const cardsInSuit = this.gameHand.getHand(this.gameHand.getWhoseTurn()).getSuit(sothlcois);\n                    return cardsInSuit[cardsInSuit.length - 1];\n                }\n            }\n        }\n        else { // I lead\n            const nonHighSpades = validChoices.filter((card) => {\n                return (card.value < 12 || card.suit !== Card_1.default.SPADES);\n            });\n            if (nonHighSpades.length) {\n                // found something that's not high spade\n                // random (without high spades)\n                return nonHighSpades[Math.floor(Math.random() * nonHighSpades.length)];\n            }\n            // else only high spades available\n            return validChoices[0]; // play lowest high spade\n        }\n        /*\n                    let foundNonHighSpade = false;\n                    for (let i = 0; i < validChoices.length; --i) {\n                        if (validChoices[i].value < 12 || validChoices[i].suit !== Card.SPADES) {\n                            // found something that's not high spade\n                            foundNonHighSpade = true;\n                            break;\n                        }\n                    }\n                    if (! foundNonHighSpade) {  // only high spades available\n                        return validChoices[0];  // play lowest high spade\n                    }\n                    // random, but not high spade\n                    let lengthWOHighSpades = validChoices.length;\n                    let randomIndex;\n                    while (true) {\n                        randomIndex = Math.floor(Math.random() * lengthWOHighSpades);\n                        if (validChoices[randomIndex].value > 11 && validChoices[randomIndex].suit === Card.SPADES) {  // high spade\n                            // swap high spade into last spot\n                            // I stopped here and decided to use filter instead\n                            // TODO: can I get better performance if I don't use filter?\n                        }\n                    }\n                }\n                */\n    }\n    simPlayCard() {\n        // TODO: I don't know a good way to tune these numbers\n        // if shooting the moon is possible, higher probability of playing a random card\n        const myCardCount = this.gameHand.getHand(this.gameHand.getWhoseTurn()).length();\n        /** out of 10 */\n        const randomIfLessThan = this.gameHand.getShootMoonPossible()\n            // first trick play random, otherwise get gradually more random over the hand\n            ? ((myCardCount > 12) ? 10 : (myCardCount * -0.8 + 11.5))\n            // if shoot the moon not possible, low probability of random\n            : 2;\n        if (Math.random() * 10 < randomIfLessThan) {\n            const vc = this.gameHand.findValidChoices();\n            return vc[Math.floor(Math.random() * vc.length)];\n        }\n        else {\n            return this.staticPlayAI();\n        }\n    }\n    dynamicPlay() {\n        const validChoices = this.gameHand.findValidChoices();\n        if (validChoices.length === 1) {\n            return validChoices[0];\n        }\n        const scoreForEachVC = validChoices.map(() => { return 0; });\n        // console.log(\"score array should be all 0s, one for each valid\");\n        // console.log(scoreForEachVC);\n        const loopCount = Math.floor((AI.LEVEL / validChoices.length) / this.gameHand.getHand(this.gameHand.getWhoseTurn()).length()) + 1;\n        for (let i = loopCount; i > 0; --i) {\n            validChoices.forEach((card, index) => {\n                const sim = new GameHand_1.default(this.gameHand);\n                const simAI = new AI(sim, this.whoAmI);\n                sim.setHands(this.speculateHands(sim.getPassingDirection()));\n                // play the card we're checking now\n                sim.playCard(card);\n                do {\n                    while (sim.turnsLeftInTrick()) {\n                        sim.playCard(simAI.simPlayCard());\n                    }\n                    sim.endTrick();\n                    if (sim.getHand(0).length()) { // more tricks to play\n                        sim.resetTrick();\n                    }\n                } while (sim.getHand(0).length()); // until there are no more tricks left to play\n                sim.endHand();\n                scoreForEachVC[index] += sim.getScore(this.whoAmI);\n                // console.log(\"just added\", sim.getScore(this.whoAmI), \"now\", scoreForEachVC[index]);\n            }); // end valid choice loop\n        } // end loop according to AI.LEVEL\n        // simple min function\n        let indexOfMin = 0;\n        console.log(validChoices[0].str(), scoreForEachVC[0] / loopCount);\n        for (let i = 1; i < validChoices.length; ++i) {\n            if (scoreForEachVC[i] < scoreForEachVC[indexOfMin]) {\n                indexOfMin = i;\n            }\n            console.log(validChoices[i].str(), scoreForEachVC[i] / loopCount);\n        }\n        return validChoices[indexOfMin];\n    }\n}\n/** number of tricks to simulate */\nAI.LEVEL = 10000;\nexports.default = AI;\n//# sourceMappingURL=AI.js.map\n\n//# sourceURL=webpack:///./build/AI.js?");

/***/ }),

/***/ "./build/Card.js":
/*!***********************!*\
  !*** ./build/Card.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Card {\n    constructor(value, suit) {\n        if (value.hasOwnProperty(\"suit\")) {\n            // copy constructor\n            const card = value;\n            this.value = card.value;\n            this.suit = card.suit;\n        }\n        else {\n            this.value = value;\n            this.suit = suit;\n        }\n    }\n    /**\n     * binary search a sorted Card array for a card,\n     * return index, -1 if not found\n     * @param sortedArray\n     * @param card\n     * @param beginIndex\n     * @param endIndexPlus1\n     */\n    static find(sortedArray, card) {\n        let beginIndex = 0;\n        let endIndexPlus1 = sortedArray.length;\n        let looking = endIndexPlus1 >> 1; // middle\n        while (looking < endIndexPlus1) {\n            if (sortedArray[looking].value === card.value) {\n                return looking;\n            }\n            if (sortedArray[looking].value > card.value) {\n                endIndexPlus1 = looking;\n            }\n            else {\n                beginIndex = looking + 1;\n            }\n            looking = (beginIndex + endIndexPlus1) >> 1; // new middle\n        }\n        return -1;\n    }\n    str() {\n        let to_return;\n        switch (this.value) {\n            case 1:\n            case 14:\n                to_return = \"Ace of \";\n                break;\n            case 11:\n                to_return = \"Jack of \";\n                break;\n            case 12:\n                to_return = \"Queen of \";\n                break;\n            case 13:\n                to_return = \"King of \";\n                break;\n            default:\n                to_return = this.value.toString();\n                to_return += \" of \";\n        }\n        switch (this.suit) {\n            case Card.CLUBS:\n                to_return += \"Clubs\";\n                break;\n            case Card.DIAMONDS:\n                to_return += \"Diamonds\";\n                break;\n            case Card.SPADES:\n                to_return += \"Spades\";\n                break;\n            case Card.HEARTS:\n                to_return += \"Hearts\";\n                break;\n            default:\n                to_return += \"UNKNOWN SUIT\";\n        }\n        return to_return;\n    }\n    hash() {\n        return (this.value << 2) + this.suit;\n    }\n}\nCard.CLUBS = 0;\nCard.DIAMONDS = 1;\nCard.SPADES = 2;\nCard.HEARTS = 3;\nCard.SUIT_COUNT = 4;\nexports.default = Card;\n//# sourceMappingURL=Card.js.map\n\n//# sourceURL=webpack:///./build/Card.js?");

/***/ }),

/***/ "./build/CardGroup.js":
/*!****************************!*\
  !*** ./build/CardGroup.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; --i) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\n/** Card container\n *\n *  maintains cards in order by suit and then by value\n */\nclass CardGroup {\n    constructor(cardGroup) {\n        this.cards = [\n            [], [], [], [] // one for each suit\n        ];\n        if (cardGroup) {\n            // copy constructor\n            cardGroup.cards.forEach((suitArray, suitIndex) => {\n                suitArray.forEach((card) => {\n                    this.cards[suitIndex].push(new Card_1.default(card));\n                });\n            });\n        }\n    }\n    /**\n     * the number of cards in given suit\n     *  - if no suit given, the number of cards in the CardGroup\n     * @param suit\n     */\n    length(suit = -1) {\n        if (suit === -1) {\n            return this.cards[0].length + this.cards[1].length + this.cards[2].length + this.cards[3].length;\n        }\n        return this.cards[suit].length;\n    }\n    /** convert fullIndex, which is the index to the CardGroup,\n     *  to a suit and index within that suit\n     */\n    getSuitAndIndex(fullIndex) {\n        let suit = 0;\n        while (suit < 4 && fullIndex >= this.cards[suit].length) {\n            fullIndex -= this.cards[suit].length;\n            suit += 1;\n        }\n        if (suit < 4) {\n            return {\n                suit: suit,\n                index: fullIndex\n            };\n        }\n        return null;\n    }\n    at(index) {\n        const suitAndIndex = this.getSuitAndIndex(index);\n        if (suitAndIndex)\n            return this.cards[suitAndIndex.suit][suitAndIndex.index];\n        return null;\n    }\n    forEach(callback) {\n        let index = 0;\n        this.cards.forEach((suit) => {\n            suit.forEach((card) => {\n                callback(card, index);\n                ++index;\n            });\n        });\n    }\n    /**\n     * returns index, -1 if not present\n     * @param card\n     */\n    find(card) {\n        let indexToReturn = Card_1.default.find(this.cards[card.suit], card);\n        if (indexToReturn === -1) {\n            return -1;\n        }\n        for (let suit = 0; suit < card.suit; ++suit) {\n            indexToReturn += this.cards[suit].length;\n        }\n        return indexToReturn;\n    }\n    remove(cardOrIndex) {\n        let indexInSuitArray, arrayToRemoveFrom;\n        if (cardOrIndex.hasOwnProperty(\"suit\")) {\n            const card = cardOrIndex;\n            arrayToRemoveFrom = this.cards[card.suit];\n            indexInSuitArray = Card_1.default.find(arrayToRemoveFrom, card);\n            if (indexInSuitArray === -1) {\n                return;\n            }\n        }\n        else { // cardOrIndex is index\n            const suitAndIndex = this.getSuitAndIndex(cardOrIndex);\n            if (!suitAndIndex) {\n                return;\n            }\n            arrayToRemoveFrom = this.cards[suitAndIndex.suit];\n            indexInSuitArray = suitAndIndex.index;\n        }\n        arrayToRemoveFrom.splice(indexInSuitArray, 1);\n    }\n    insert(card) {\n        const arrayToInsertTo = this.cards[card.suit];\n        let i = 0;\n        for (; i < arrayToInsertTo.length; ++i) {\n            if (arrayToInsertTo[i].value > card.value) {\n                break;\n            }\n        }\n        arrayToInsertTo.splice(i, 0, card);\n    }\n    /** removes all the cards from this CardGroup */\n    clear() {\n        this.cards.forEach((suitArray) => {\n            suitArray.length = 0;\n        });\n    }\n    /**\n     * fill with 52 cards\n     */\n    fill() {\n        this.cards.forEach((suitArray, suitNumber) => {\n            suitArray.length = 0;\n            for (let i = 2; i < 15; ++i) {\n                suitArray.push(new Card_1.default(i, suitNumber));\n            }\n        });\n    }\n    /** choose a random Card out of the CardGroup,\n     *  remove it, and return it\n     */\n    dealOne() {\n        const index = Math.floor(Math.random() * this.length());\n        const toReturn = this.at(index);\n        this.remove(index);\n        // @ts-ignore trust me, it will not be null\n        return toReturn;\n    }\n    /** from hand of 13 cards\n     *\n     *  precondition: `length() === 13`\n     */\n    pickRandom(n) {\n        const toReturn = [];\n        const indexes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        shuffleArray(indexes);\n        for (let i = 0; i < n; ++i) {\n            toReturn.push(this.at(indexes[i]));\n        }\n        return toReturn;\n    }\n    /** returns a reference to an array of the cards in one suit\n     */\n    getSuit(suit) {\n        return this.cards[suit];\n    }\n    /** returns an array with all the cards in this CardGroup */\n    slice() {\n        return this.cards[0].concat(this.cards[1], this.cards[2], this.cards[3]);\n    }\n}\nexports.default = CardGroup;\n//# sourceMappingURL=CardGroup.js.map\n\n//# sourceURL=webpack:///./build/CardGroup.js?");

/***/ }),

/***/ "./build/Clickable.js":
/*!****************************!*\
  !*** ./build/Clickable.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Clickable {\n    constructor(x, y, w, h, onClick) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        this.onClick = onClick;\n    }\n    contains(x, y) {\n        return (x >= this.x && y >= this.y && x < this.x + this.w && y < this.y + this.h);\n    }\n}\nexports.default = Clickable;\n//# sourceMappingURL=Clickable.js.map\n\n//# sourceURL=webpack:///./build/Clickable.js?");

/***/ }),

/***/ "./build/Drawer.js":
/*!*************************!*\
  !*** ./build/Drawer.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nconst Clickable_1 = __importDefault(__webpack_require__(/*! ./Clickable */ \"./build/Clickable.js\"));\nconst framesPerCardAnimation = 10;\nclass CardAnimation {\n    constructor() {\n        this.fromX = 0.4;\n        this.fromY = -1;\n        this.toX = this.fromX;\n        this.toY = this.fromY;\n        this.frame = 0;\n        this.endFrame = framesPerCardAnimation;\n    }\n    /** returns array of current x position and current y position\n     *  proportional to canvas width and height\n     */\n    current() {\n        if (this.endFrame === 0) {\n            return [this.toX, this.toY];\n        }\n        const distanceX = this.toX - this.fromX;\n        const distanceY = this.toY - this.fromY;\n        const through = this.frame / this.endFrame;\n        return [through * distanceX + this.fromX, through * distanceY + this.fromY];\n    }\n    /** x and y proportional to canvas width and height */\n    setLocation(x, y) {\n        this.fromX = x;\n        this.fromY = y;\n        this.toX = x;\n        this.toY = y;\n        this.frame = this.endFrame;\n    }\n    /** x and y proportional to canvas width and height */\n    setDestination(x, y) {\n        if ((Math.abs(this.toX - x) > 0.0078125) || (Math.abs(this.toY - y) > 0.0078125)) {\n            // new destination\n            [this.fromX, this.fromY] = this.current();\n            this.toX = x;\n            this.toY = y;\n            this.endFrame = framesPerCardAnimation;\n            this.frame = 0;\n        }\n        return this.current();\n    }\n    /** frame */\n    update() {\n        this.frame += (this.frame < this.endFrame) ? 1 : 0;\n    }\n}\nclass Drawer {\n    constructor(context, assets, gui) {\n        this.cardWidth = 42;\n        this.cardHeight = 58.5;\n        this.vertical = false;\n        this.fontSize = 18;\n        this.context = context;\n        this.assets = assets;\n        this.gui = gui;\n        this.cardAnimations = new Map();\n        for (let value = 2; value < 15; ++value) {\n            for (let suit = 0; suit < Card_1.default.SUIT_COUNT; ++suit) {\n                this.cardAnimations.set((value << 2) + suit, new CardAnimation());\n            }\n        }\n        // this doesn't work, don't know why (see to-do notes below)\n        this.context.font = \"\" + this.fontSize + \"px Arial\";\n        this.context.textBaseline = \"top\";\n    }\n    resize(zoom) {\n        this.vertical = this.context.canvas.height > this.context.canvas.width;\n        this.cardWidth = zoom * this.context.canvas.width / (this.vertical ? 5.4 : 10.6);\n        this.cardHeight = this.cardWidth * Drawer.assetHeight / Drawer.assetWidth;\n        console.log(\"card width set to\", this.cardWidth);\n    }\n    /** locations for animations */\n    setAiCards() {\n        for (let player = 1; player < 4; ++player) {\n            const [x, y] = Drawer.playerPosition(player);\n            this.gui.game.hand.getHand(player).forEach((card, _index) => {\n                var _a;\n                (_a = this.cardAnimations.get(card.hash())) === null || _a === void 0 ? void 0 : _a.setLocation(x, y);\n            });\n        }\n    }\n    drawCard(card, x, y) {\n        const assetX = (((card.value === 14) ? 1 : card.value) - 1) * Drawer.valueXMult;\n        const assetY = Drawer.suitAssetYs[card.suit];\n        const canvas = this.context.canvas;\n        const width = canvas.width;\n        const height = canvas.height;\n        const anim = this.cardAnimations.get(card.hash());\n        if (!anim) {\n            throw \"anim not found with card \" + card.str();\n        }\n        const [propX, propY] = anim.setDestination(x / width, y / height);\n        this.context.drawImage(this.assets, assetX, assetY, Drawer.assetWidth, Drawer.assetHeight, propX * width, propY * height, this.cardWidth, this.cardHeight);\n        anim.update();\n    }\n    /** is this index the leftmost card in any suit in the hand? */\n    static startsNewSuit(index, hand) {\n        if (index === 0) {\n            return true;\n        }\n        if (index >= hand.length()) {\n            return false;\n        }\n        return (hand.at(index - 1).suit !== hand.at(index).suit);\n    }\n    /** if drawing the hand on two rows, which index starts the new row? */\n    static getRowBreak(hand) {\n        const handLength = hand.length();\n        let checkingIndex = handLength >> 1; // middle\n        if (Drawer.startsNewSuit(checkingIndex, hand)) {\n            return checkingIndex;\n        }\n        else { // checking in middle of suit\n            // go towards break between suit 1 and 2\n            let direction = (hand.length(0) + hand.length(1) > checkingIndex) ? 1 : -1;\n            checkingIndex += direction;\n            // don't put more than 7 on a row\n            const handLengthM8 = handLength - 8;\n            while (checkingIndex > handLengthM8 && checkingIndex < 8) {\n                if (Drawer.startsNewSuit(checkingIndex, hand)) {\n                    return checkingIndex;\n                }\n                checkingIndex += direction;\n            }\n            // check the other direction\n            direction = 0 - direction;\n            checkingIndex = (handLength >> 1) + direction;\n            while (checkingIndex > handLengthM8 && checkingIndex < 8) {\n                if (Drawer.startsNewSuit(checkingIndex, hand)) {\n                    return checkingIndex;\n                }\n                checkingIndex += direction;\n            }\n            // couldn't find a good break between suits, so break in the middle of a suit\n            return handLength >> 1;\n        }\n    }\n    drawHand(cardClick) {\n        const hand = this.gui.game.hand.getHand(0);\n        const cardCount = hand.length();\n        // build 2 rows\n        const rows = [[], []];\n        let firstIndexInRow1 = 0; // start by assuming all 1 row\n        if (this.vertical && cardCount > 7) {\n            // need to make 2 rows\n            firstIndexInRow1 = Drawer.getRowBreak(hand);\n        }\n        let rowIndex = 0;\n        hand.forEach((card, index) => {\n            if (index >= firstIndexInRow1) {\n                rowIndex = 1;\n            }\n            rows[rowIndex].push({ card: card, index: index });\n        });\n        // draw them\n        let rowY = this.context.canvas.height -\n            ((this.cardHeight + Drawer.verticalPadding) * 2);\n        // console.log(\"card width:\", this.cardWidth);\n        const maxRowLength = Math.max(rows[0].length, rows[1].length);\n        // console.log(\"max row length:\", maxRowLength);\n        /** number of cards that can fit on a row without overlapping */\n        const cardLimitPerRow = Math.floor(this.context.canvas.width / (this.cardWidth * 1.05));\n        /** x distance from left side of one card to left side of the next */\n        const cardSpaceWidth = (maxRowLength > cardLimitPerRow) ?\n            (this.context.canvas.width - (this.cardWidth + 10)) / (maxRowLength - 1) :\n            this.cardWidth * 1.05;\n        // console.log(\"cardSpaceWidth:\", cardSpaceWidth);\n        rows.forEach((row) => {\n            const xForRowBegin = this.context.canvas.width / 2 - // middle\n                ((cardSpaceWidth * (row.length - 1) + this.cardWidth) / 2); // minus half the width of all the cards\n            // last card doesn't take all of ^ cardSpaceWidth, only cardWidth\n            row.forEach((cardAndIndex, indexInRow) => {\n                // only if it's not in cards to pass\n                if (this.gui.cardsToPass.find(cardAndIndex.card) === -1) {\n                    const x = xForRowBegin +\n                        (cardSpaceWidth * indexInRow); // plus the width of the cards we've already drawn in this row\n                    this.drawCard(cardAndIndex.card, x, rowY);\n                    this.gui.clickables.push(new Clickable_1.default(x, rowY, this.cardWidth, this.cardHeight, () => { cardClick(cardAndIndex.card); }));\n                }\n            });\n            rowY += this.cardHeight + Drawer.verticalPadding;\n        });\n    }\n    drawPlayerScore(player, x, y) {\n        this.context.fillText(\"Game: \" + this.gui.game.scores[player], x, y);\n        this.context.fillText(\"Hand: \" + this.gui.game.hand.getScore(player), x, y + this.fontSize);\n    }\n    drawScores() {\n        // TODO: optimization: figure out why putting these (font and baseline) in Drawer constructor doesn't work\n        this.context.font = \"\" + this.fontSize + \"px Arial\";\n        this.context.textBaseline = \"top\";\n        this.context.fillStyle = \"#88ff88\";\n        // player 0\n        this.context.fillText(\"Game: \" + this.gui.game.scores[0] + \"  Hand: \" + this.gui.game.hand.getScore(0), 5, this.yForBottomMiddle() + (this.cardHeight + Drawer.verticalPadding));\n        // player 1\n        this.drawPlayerScore(1, 5, this.context.canvas.height / 4);\n        // player 2\n        this.drawPlayerScore(2, (this.context.canvas.width + this.cardWidth + 10) / 2, 5);\n        // player 3\n        const w = this.context.measureText(\"Game: 100\").width;\n        this.drawPlayerScore(3, this.context.canvas.width - (w + 5), this.context.canvas.height / 3);\n    }\n    yForBottomMiddle() {\n        return this.context.canvas.height -\n            ((this.vertical ? 3 : 2) *\n                (this.cardHeight + Drawer.verticalPadding) +\n                Drawer.spaceAboveHand); // space for score or something\n    }\n    drawCardsToPass() {\n        const rowY = this.yForBottomMiddle();\n        let x = this.context.canvas.width / 2 - (1.5 * this.cardWidth + 10);\n        this.gui.cardsToPass.forEach((card) => {\n            this.drawCard(card, x, rowY);\n            this.gui.clickables.push(new Clickable_1.default(x, rowY, this.cardWidth, this.cardHeight, () => { this.gui.removeFromPass(card); }));\n            x += this.cardWidth + 10;\n        });\n    }\n    drawPlayedCards() {\n        const y = Math.min(this.yForBottomMiddle(), this.context.canvas.height / 2);\n        const x = (this.context.canvas.width - this.cardWidth) / 2;\n        const playedCards = this.gui.game.hand.getPlayedCards();\n        if (playedCards[0].value) {\n            this.drawCard(playedCards[0], x, y);\n        }\n        if (playedCards[1].value) {\n            this.drawCard(playedCards[1], x - (10 + this.cardWidth), y - (this.cardHeight / 2 + 5));\n        }\n        if (playedCards[2].value) {\n            this.drawCard(playedCards[2], x, y - (this.cardHeight + 10));\n        }\n        if (playedCards[3].value) {\n            this.drawCard(playedCards[3], x + (10 + this.cardWidth), y - (this.cardHeight / 2 + 5));\n        }\n    }\n    /** animated going away */\n    drawPreviousTrick() {\n        if (this.gui.game.hand.getPlayedCardCount() !== 4) {\n            const tr = this.gui.game.hand.getPreviousTrick();\n            const [destX, destY] = Drawer.playerPosition(tr.whoWon);\n            // console.log(\"prev trick x \" + destX + \"  y \" + destY);\n            for (let card of tr.cards) {\n                this.drawCard(card, destX * this.context.canvas.width, destY * this.context.canvas.height);\n            }\n        }\n    }\n    /** locations where players are sitting proportional to canvas */\n    static playerPosition(player) {\n        return [player ? (player - 1.6) : 0.4,\n            (player === 2) ? -0.5 : ((player === 0) ? 1.5 : 0.2)];\n    }\n    /**\n     *\n     * @param x\n     * @param y\n     * @param size\n     * @param direction number of quadrants clockwise from right\n     */\n    drawArrow(x, y, size, direction, opaque) {\n        this.context.globalAlpha = opaque ? 1 : 0.5;\n        this.context.fillStyle = \"orange\";\n        this.context.translate(x + size / 2, y + size / 2);\n        this.context.rotate(direction * Math.PI / 2);\n        this.context.beginPath();\n        this.context.moveTo(size / 2, 0);\n        this.context.lineTo(0, 0 - size / 2);\n        this.context.lineTo(0, 0 - size / 4);\n        this.context.lineTo(0 - size / 2, 0 - size / 4);\n        this.context.lineTo(0 - size / 2, size / 4);\n        this.context.lineTo(0, size / 4);\n        this.context.lineTo(0, size / 2);\n        this.context.fill();\n        // undo rotation and translation and alpha\n        this.context.rotate(0 - direction * Math.PI / 2);\n        this.context.translate(0 - (x + size / 2), 0 - (y + size / 2));\n        this.context.globalAlpha = 1;\n    }\n    drawPassButton(opaque) {\n        const size = 80;\n        const x = this.context.canvas.width / 2 - (size / 2);\n        const y = this.context.canvas.height -\n            ((this.vertical ? 3 : 2) *\n                (this.cardHeight + Drawer.verticalPadding) +\n                Drawer.spaceAboveHand +\n                Drawer.verticalPadding +\n                size);\n        this.drawArrow(x, y, size, this.gui.game.getPassingDirection() + 1, opaque);\n        this.gui.clickables.push(new Clickable_1.default(x, y, size, size, () => { this.gui.passButtonClick(); }));\n    }\n    drawEnd(winners) {\n        this.context.fillStyle = \"lightgray\";\n        const lineCount = winners.length + 1;\n        const lineSize = this.fontSize + 2;\n        // TODO: get names from somewhere if they are customizable\n        const winnerNames = [\"You\", \"Left\", \"North\", \"3 o'Clock\"];\n        const boxHeight = (lineCount + 2) * lineSize;\n        // TODO: max of measure text for all names and \"winners\" instead of winnerNames[3]\n        const boxWidth = this.context.measureText(winnerNames[3]).width + (2 * lineSize);\n        const boxX = (this.context.canvas.width - boxWidth) / 2;\n        const boxY = (this.context.canvas.height - boxHeight) / 2;\n        this.context.fillRect(boxX, boxY, boxWidth, boxHeight);\n        // TODO: optimization: figure out why putting these (font and baseline) in Drawer constructor doesn't work\n        this.context.font = \"\" + this.fontSize + \"px Arial\";\n        this.context.textBaseline = \"top\";\n        this.context.fillStyle = \"black\";\n        this.context.fillText(\"winner\" + ((winners.length > 1) ? \"s:\" : \":\"), boxX + lineSize, boxY + lineSize);\n        winners.forEach((player, index) => {\n            this.context.fillText(winnerNames[player], boxX + lineSize, boxY + ((index + 2) * lineSize));\n        });\n    }\n    background() {\n        this.context.fillStyle = \"purple\";\n        this.context.fillRect(0, 0, this.context.canvas.width, this.context.canvas.height);\n    }\n}\n// coordinates from image file\nDrawer.suitAssetYs = [0, 528, 352, 176];\nDrawer.assetHeight = 156;\nDrawer.valueXMult = 131.5834;\nDrawer.assetWidth = 112;\nDrawer.verticalPadding = 5;\nDrawer.spaceAboveHand = 20;\nexports.default = Drawer;\n//# sourceMappingURL=Drawer.js.map\n\n//# sourceURL=webpack:///./build/Drawer.js?");

/***/ }),

/***/ "./build/Game.js":
/*!***********************!*\
  !*** ./build/Game.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GameHand_1 = __importDefault(__webpack_require__(/*! ./GameHand */ \"./build/GameHand.js\"));\nclass Game {\n    constructor(game) {\n        this.hand = new GameHand_1.default();\n        this.scores = [0, 0, 0, 0];\n        this.winners = []; // empty if game is not finished\n        this.passingIndex = 0;\n        if (game) {\n            // copy constructor\n            this.hand = new GameHand_1.default(game.hand);\n            this.scores = game.scores;\n            this.winners = game.winners;\n            this.passingIndex = game.passingIndex;\n        }\n    }\n    reset() {\n        this.winners.length = 0;\n        this.passingIndex = 0;\n        this.scores[0] = 0;\n        this.scores[1] = 0;\n        this.scores[2] = 0;\n        this.scores[3] = 0;\n    }\n    endHand() {\n        let gameOver = false;\n        for (let player = 0; player < 4; ++player) {\n            this.scores[player] += this.hand.getScore(player);\n            if (this.scores[player] > 99) {\n                gameOver = true;\n            }\n        }\n        if (gameOver) {\n            this.winners.push(0);\n            for (let player = 1; player < 4; ++player) {\n                if (this.scores[player] < this.scores[this.winners[0]]) { // better\n                    this.winners.length = 0;\n                    this.winners.push(player);\n                }\n                else if (this.scores[player] === this.scores[this.winners[0]]) { // tie\n                    this.winners.push(player);\n                }\n            }\n        }\n        else {\n            this.changePassing();\n        }\n    }\n    changePassing() {\n        this.passingIndex = (this.passingIndex + 1) % 4;\n    }\n    getPassingDirection() {\n        return Game.passingDirections[this.passingIndex];\n    }\n}\nGame.passingDirections = [1, 3, 2, 0]; // left, right, across, keep\nexports.default = Game;\n//# sourceMappingURL=Game.js.map\n\n//# sourceURL=webpack:///./build/Game.js?");

/***/ }),

/***/ "./build/GameHand.js":
/*!***************************!*\
  !*** ./build/GameHand.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CardGroup_1 = __importDefault(__webpack_require__(/*! ./CardGroup */ \"./build/CardGroup.js\"));\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nconst nullCard = new Card_1.default(0, 0);\n/**\n * each hand, call these in this order:\n * ```\n * resetHand();\n * dealHands();\n * pass(fromPlayer, toPlayer, passedCards);\n * receivePassedCards();  // TODO: return which cards (for UI)\n * resetTrick();\n * playCard(card);  // TODO: return hearts broken (for UI)\n * endTrick();  // TODO: returns who took the trick? (for UI)\n * endHand();  // returns who shot the moon\n * ```\n */\nclass GameHand {\n    constructor(gameHand) {\n        this.hands = [new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default()];\n        this.scores = [0, 0, 0, 0];\n        this.passingDirection = 0;\n        this.passedCardsToPlayer = [[], [], [], []]; // first index is player passed to\n        this.passCount = 0;\n        // trick\n        this.playedCards = [nullCard, nullCard, nullCard, nullCard];\n        this.playedCardCount = 0;\n        this.trickLeader = 0;\n        this.whoseTurn = 0;\n        this.heartsBroken = false;\n        this.pointsPlayedThisTrick = false;\n        /** updates in `endTrick` */\n        this.trickHistory = [];\n        this.shootMoonPossible = true;\n        this.observerList = [];\n        if (gameHand) {\n            // copy constructor\n            this.hands[0] = new CardGroup_1.default(gameHand.hands[0]);\n            this.hands[1] = new CardGroup_1.default(gameHand.hands[1]);\n            this.hands[2] = new CardGroup_1.default(gameHand.hands[2]);\n            this.hands[3] = new CardGroup_1.default(gameHand.hands[3]);\n            this.scores = gameHand.scores.map(x => x);\n            this.passingDirection = gameHand.passingDirection;\n            for (let player = 0; player < 4; ++player) {\n                this.passedCardsToPlayer[player].length = 0;\n                gameHand.passedCardsToPlayer[player].forEach((card) => {\n                    this.passedCardsToPlayer[player].push(new Card_1.default(card));\n                });\n            }\n            this.passCount = gameHand.passCount;\n            this.playedCards[0] = new Card_1.default(gameHand.playedCards[0]);\n            this.playedCards[1] = new Card_1.default(gameHand.playedCards[1]);\n            this.playedCards[2] = new Card_1.default(gameHand.playedCards[2]);\n            this.playedCards[3] = new Card_1.default(gameHand.playedCards[3]);\n            this.playedCardCount = gameHand.playedCardCount;\n            this.trickLeader = gameHand.trickLeader;\n            this.whoseTurn = gameHand.whoseTurn;\n            this.heartsBroken = gameHand.heartsBroken;\n            this.pointsPlayedThisTrick = gameHand.pointsPlayedThisTrick;\n            this.trickHistory = gameHand.trickHistory.map((tr) => {\n                return {\n                    cards: tr.cards.map((card) => new Card_1.default(card)),\n                    whoWon: tr.whoWon\n                };\n            });\n            this.shootMoonPossible = gameHand.shootMoonPossible;\n            // don't copy observer list\n        }\n    }\n    registerObserver(ob) {\n        this.observerList.push(ob);\n    }\n    getWhoseTurn() {\n        return this.whoseTurn;\n    }\n    getHand(player) {\n        return this.hands[player];\n    }\n    getScore(player) {\n        return this.scores[player];\n    }\n    getPassingDirection() {\n        return this.passingDirection;\n    }\n    turnsLeftInTrick() {\n        return 4 - this.playedCardCount;\n    }\n    heartsIsBroken() {\n        return this.heartsBroken;\n    }\n    getPassCount() {\n        return this.passCount;\n    }\n    getPlayedCards() {\n        return this.playedCards;\n    }\n    getPlayedCardCount() {\n        return this.playedCardCount;\n    }\n    /** changes with `GameHand.endTrick()`\n     *\n     *  Between `endTrick` and `resetTrick`, this returns the same cards as `getPlayedCards`\n     */\n    getPreviousTrick() {\n        const l = this.trickHistory.length;\n        return l ? this.trickHistory[l - 1] : {\n            cards: [],\n            whoWon: 0\n        };\n    }\n    getTrickLeader() {\n        return this.trickLeader;\n    }\n    getPassedCardsToPlayer(player) {\n        return this.passedCardsToPlayer[player];\n    }\n    getShootMoonPossible() {\n        return this.shootMoonPossible;\n    }\n    /**\n     * to be called on keeper hand to say we're done passing\n     */\n    setPassed() {\n        this.passCount = 4;\n    }\n    /** to be called with speculated hands in AI simulation */\n    setHands(hands) {\n        this.hands = hands;\n    }\n    resetHand(passingDirection) {\n        this.passingDirection = passingDirection;\n        for (let i = 0; i < 4; ++i) {\n            this.hands[i].clear();\n            this.scores[i] = 0;\n            this.passedCardsToPlayer[i].length = 0;\n        }\n        this.passCount = 0;\n        this.heartsBroken = false;\n        this.trickHistory.length = 0;\n        this.shootMoonPossible = true;\n        this.observerList.forEach((ob) => { ob.resetHand(); });\n    }\n    dealHands() {\n        const deck = new CardGroup_1.default();\n        deck.fill();\n        while (deck.length()) {\n            for (let i = 0; i < 4; ++i) {\n                const dealt = deck.dealOne();\n                this.hands[i].insert(dealt);\n                if (dealt.value === 2 && dealt.suit === Card_1.default.CLUBS) {\n                    this.whoseTurn = i;\n                }\n            }\n        }\n        this.observerList.forEach((ob) => { ob.dealHands(); });\n    }\n    pass(fromPlayer, toPlayer, cards) {\n        cards.forEach((card) => {\n            this.passedCardsToPlayer[toPlayer].push(card);\n            this.hands[fromPlayer].remove(card);\n        });\n        ++this.passCount;\n        this.observerList.forEach((ob) => { ob.pass(fromPlayer, toPlayer, cards); });\n    }\n    receivePassedCards() {\n        for (let playerIndex = 0; playerIndex < 4; ++playerIndex) {\n            this.passedCardsToPlayer[playerIndex].forEach((card) => {\n                this.hands[playerIndex].insert(card);\n                if (card.value === 2 && card.suit === Card_1.default.CLUBS) {\n                    this.whoseTurn = playerIndex;\n                }\n            });\n        }\n        this.observerList.forEach((ob) => { ob.receivePassedCards(); });\n    }\n    resetTrick() {\n        this.playedCards = [nullCard, nullCard, nullCard, nullCard];\n        this.playedCardCount = 0;\n        this.trickLeader = this.whoseTurn;\n        this.pointsPlayedThisTrick = false;\n        this.observerList.forEach((ob) => { ob.resetTrick(); });\n    }\n    takesLead(card) {\n        return (card.suit === this.playedCards[this.trickLeader].suit &&\n            card.value > this.playedCards[this.trickLeader].value);\n    }\n    playCard(card) {\n        // console.log(\"playing card on turn:\", this.whoseTurn);\n        this.hands[this.whoseTurn].remove(card);\n        this.playedCards[this.whoseTurn] = card;\n        // console.log(\"added card to playedCards:\", this.playedCards);\n        ++this.playedCardCount;\n        if (this.takesLead(card)) {\n            this.trickLeader = this.whoseTurn;\n        }\n        let showingOnlyHearts = false;\n        if (card.suit === Card_1.default.HEARTS) {\n            if (this.playedCardCount === 1 && !this.heartsBroken) {\n                showingOnlyHearts = true;\n            }\n            this.heartsBroken = true; // TODO: alternate rule q of spades breaks hearts?\n        }\n        if (this.pointsFor(card)) {\n            this.pointsPlayedThisTrick = true;\n        }\n        // give observer who played the card\n        const byPlayer = this.whoseTurn;\n        // see if it's still possible to shoot the moon\n        if (this.shootMoonPossible) {\n            if (this.pointsPlayedThisTrick) {\n                let nonZeroScore = -1;\n                for (let player = 0; player < 4; ++player) {\n                    if (this.getScore(player)) {\n                        nonZeroScore = player;\n                        break;\n                    }\n                }\n                if (nonZeroScore !== -1) {\n                    // see whether this player has played yet this trick\n                    let thisPlayerPLayed = false;\n                    let goingThroughTurns = (byPlayer + 5 - this.getPlayedCardCount()) % 4; // first turn this trick\n                    for (let turn = this.getPlayedCardCount(); turn > 0; --turn) {\n                        if (goingThroughTurns === nonZeroScore) {\n                            thisPlayerPLayed = true;\n                            break;\n                        }\n                        goingThroughTurns = (goingThroughTurns + 1) % 4;\n                    }\n                    if (thisPlayerPLayed) {\n                        if (nonZeroScore !== this.getTrickLeader()) {\n                            this.shootMoonPossible = false;\n                            // for testing\n                            // console.log(\"INFO: this is the point when it becomes impossible for anyone to shoot the moon\");\n                        }\n                    }\n                }\n            }\n        }\n        this.whoseTurn = (this.whoseTurn + 1) % 4;\n        this.observerList.forEach((ob) => { ob.seeCardPlayed(card, byPlayer, showingOnlyHearts); });\n    }\n    pointsFor(card) {\n        return (card.suit === Card_1.default.HEARTS) ? 1 : ((card.value === 12 && card.suit === Card_1.default.SPADES) ? 13 : 0);\n    }\n    endTrick() {\n        this.playedCards.forEach((card) => {\n            this.scores[this.trickLeader] += this.pointsFor(card);\n        });\n        this.whoseTurn = this.trickLeader;\n        this.trickHistory.push({\n            cards: this.playedCards.slice(),\n            whoWon: this.trickLeader\n        });\n    }\n    /**\n     * returns who shot the moon, -1 if no one\n     */\n    endHand() {\n        // need the played cards to go away so gui doesn't try to draw them\n        this.playedCards = [nullCard, nullCard, nullCard, nullCard];\n        this.playedCardCount = 0;\n        for (let winPlayer = 0; winPlayer < 4; ++winPlayer) { // check for shoot the moon\n            if (this.scores[winPlayer] === 26) {\n                this.scores[winPlayer] = 0;\n                for (let losePlayer = 0; losePlayer < 4; ++losePlayer) {\n                    if (losePlayer !== winPlayer) {\n                        this.scores[losePlayer] = 26;\n                    }\n                }\n                return winPlayer;\n            }\n            else if (this.scores[winPlayer] > 0) { // 1 to 25 points\n                return -1;\n            }\n        }\n        alert(\"this should never happen, invalid scores\");\n        console.log(\"this should never happen, invalid scores\");\n        return -2;\n    }\n    // rules of the game\n    findValidChoices() {\n        const hand = this.hands[this.whoseTurn];\n        if (hand.length() === 13) { // first trick\n            if (this.playedCardCount === 0) { // first player\n                return [new Card_1.default(2, Card_1.default.CLUBS)];\n            }\n            // not first player\n            if (hand.length(Card_1.default.CLUBS)) {\n                return hand.getSuit(Card_1.default.CLUBS);\n            }\n            else { // no clubs\n                const validChoices = [];\n                hand.forEach((card) => {\n                    if (!this.pointsFor(card)) {\n                        validChoices.push(card);\n                    }\n                });\n                if (validChoices.length) {\n                    return validChoices;\n                }\n                // only points in hand\n                return hand.slice();\n            }\n        }\n        else { // not first trick\n            if (this.playedCardCount === 0) { // leading trick\n                if (this.heartsBroken) {\n                    return hand.slice();\n                }\n                // hearts not broken\n                if (hand.length(Card_1.default.HEARTS) === hand.length()) { // only hearts in hand\n                    return hand.slice();\n                }\n                // non-hearts in hand, play anything not hearts\n                const validChoices = [];\n                hand.forEach((card) => {\n                    if (card.suit !== Card_1.default.HEARTS) {\n                        validChoices.push(card);\n                    }\n                });\n                return validChoices;\n            }\n            else { // not leading trick\n                if (hand.length(this.playedCards[this.trickLeader].suit)) { // have suit that is lead\n                    return hand.getSuit(this.playedCards[this.trickLeader].suit);\n                }\n                // don't have matching suit\n                return hand.slice();\n            }\n        }\n    }\n}\nexports.default = GameHand;\n//# sourceMappingURL=GameHand.js.map\n\n//# sourceURL=webpack:///./build/GameHand.js?");

/***/ }),

/***/ "./build/Gui.js":
/*!**********************!*\
  !*** ./build/Gui.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nconst Game_1 = __importDefault(__webpack_require__(/*! ./Game */ \"./build/Game.js\"));\nconst AI_1 = __importDefault(__webpack_require__(/*! ./AI */ \"./build/AI.js\"));\nconst CardGroup_1 = __importDefault(__webpack_require__(/*! ./CardGroup */ \"./build/CardGroup.js\"));\nconst Waiter_1 = __importDefault(__webpack_require__(/*! ./Waiter */ \"./build/Waiter.js\"));\nconst Drawer_1 = __importDefault(__webpack_require__(/*! ./Drawer */ \"./build/Drawer.js\"));\nconst Stats_1 = __importDefault(__webpack_require__(/*! ./Stats */ \"./build/Stats.js\"));\n/*\nfunction workerFunction() {\n    // to run without a server\n    // paste compiled and packed worker code here\n    // and switch worker definition in constructor\n}\n*/\n/** controller */\nclass Gui {\n    constructor(context, assets, storage) {\n        this.clickables = [];\n        this.game = new Game_1.default();\n        this.ais = [];\n        this.cardsToPass = new CardGroup_1.default();\n        this.humanPlayerPassed = false;\n        this.receivedCards = [];\n        this.showingPassedCards = false;\n        this.waiter = new Waiter_1.default();\n        this.storage = storage;\n        this.drawer = new Drawer_1.default(context, assets, this);\n        this.stats = new Stats_1.default(storage);\n        // this.worker = new Worker(URL.createObjectURL(new Blob([\"(\"+workerFunction.toString()+\")()\"], {type: 'text/javascript'})));\n        this.worker = new Worker(\"workerbundle.js\");\n        this.worker.addEventListener('message', (message) => {\n            console.log(\"received message from worker:\");\n            console.log(message);\n            this.handleMessage(message.data);\n        });\n        this.restore();\n        setInterval(() => { this.draw(); }, 40);\n    }\n    resize(zoom) {\n        this.drawer.resize(zoom);\n    }\n    /** you can't stringify Game or AI with observerList\n     *  because it's infinitely recursive\n     */\n    static filterOutObserverList(key, value) {\n        return (key === \"observerList\") ? undefined : value;\n    }\n    workerMessagePassing() {\n        const cl = JSON.parse(JSON.stringify(this.ais, Gui.filterOutObserverList));\n        console.log(\"clone:\");\n        console.log(cl);\n        this.worker.postMessage(cl);\n    }\n    workerMessagePlay() {\n        console.log(\"sending play message to worker, turn:\", this.game.hand.getWhoseTurn());\n        const cl = JSON.parse(JSON.stringify(this.ais[this.game.hand.getWhoseTurn()], Gui.filterOutObserverList));\n        this.worker.postMessage(cl);\n    }\n    deleteSave() {\n        this.storage.removeItem(\"game\");\n        this.storage.removeItem(\"ais\");\n        this.storage.removeItem(\"hpp\");\n    }\n    save() {\n        const gameString = JSON.stringify(this.game, Gui.filterOutObserverList);\n        const aiString = JSON.stringify(this.ais, Gui.filterOutObserverList);\n        this.storage.setItem(\"game\", gameString);\n        this.storage.setItem(\"ais\", aiString);\n        this.storage.setItem(\"hpp\", this.humanPlayerPassed ? \"t\" : \"f\");\n    }\n    /** from local storage */\n    restore() {\n        const gameString = this.storage.getItem(\"game\");\n        const aiString = this.storage.getItem(\"ais\");\n        const hpp = this.storage.getItem(\"hpp\");\n        this.humanPlayerPassed = hpp === \"t\";\n        if (gameString && aiString) {\n            const ais = JSON.parse(aiString);\n            this.game = new Game_1.default(JSON.parse(gameString));\n            this.ais = [\n                null,\n                new AI_1.default(ais[1]),\n                new AI_1.default(ais[2]),\n                new AI_1.default(ais[3])\n            ];\n            this.ais[1].setHand(this.game.hand);\n            this.ais[2].setHand(this.game.hand);\n            this.ais[3].setHand(this.game.hand);\n        }\n        else {\n            this.game = new Game_1.default();\n            this.ais = [\n                null,\n                new AI_1.default(this.game.hand, 1),\n                new AI_1.default(this.game.hand, 2),\n                new AI_1.default(this.game.hand, 3)\n            ];\n        }\n        for (let player = 1; player < 4; ++player) {\n            this.game.hand.registerObserver(this.ais[player]);\n        }\n        this.game.hand.registerObserver(this);\n        if (!gameString) {\n            this.game.reset();\n            this.game.hand.resetHand(this.game.getPassingDirection());\n        }\n        this.drawer.setAiCards();\n    }\n    /**\n     * player clicks on card to pass\n     * @param card\n     */\n    addToPass(card) {\n        console.log(\"clicked to pass\", card.str());\n        if (this.cardsToPass.length() < 3) {\n            this.cardsToPass.insert(card);\n            console.log(\"number of cards to pass\", this.cardsToPass.length());\n        }\n    }\n    removeFromPass(card) {\n        console.log(\"clicked to remove\", card.str());\n        this.cardsToPass.remove(card);\n    }\n    /**\n     * player clicks on card to play\n     * @param card\n     */\n    playCard(card) {\n        console.log(\"clicked to play\", card.str());\n        const validChoices = this.game.hand.findValidChoices();\n        if (validChoices.some((validCard) => {\n            return (card.value === validCard.value && card.suit === validCard.suit);\n        })) {\n            this.game.hand.playCard(card);\n        }\n    }\n    passButtonClick() {\n        if (!(this.cardsToPass.length() > 2)) {\n            return;\n        }\n        this.humanPlayerPassed = true;\n        const passingCards = this.cardsToPass.slice();\n        this.cardsToPass.clear();\n        this.game.hand.pass(0, this.game.getPassingDirection(), passingCards);\n    }\n    draw() {\n        // console.log(\"gui draw here\");\n        this.drawer.background();\n        this.clickables.length = 0;\n        this.drawer.drawScores();\n        if (!this.humanPlayerPassed) { // passing needs to be done\n            //passing\n            this.drawer.drawHand((card) => { this.addToPass(card); });\n            this.drawer.drawCardsToPass();\n            this.drawer.drawPassButton(this.cardsToPass.length() === 3);\n        }\n        else if (this.game.hand.getPassCount() < 4) {\n            this.drawer.drawHand((card) => { console.log(\"clicked on card \" + card.str() + \" when human already passed\"); });\n        }\n        else if (this.showingPassedCards) {\n            console.log(\"got draw in showing passed cards, length:\", this.cardsToPass.length());\n            this.drawer.drawHand((card) => { console.log(\"clicked card \" + card.str() + \" while showing passed, but you shouldn't see this because click goes to skipping timer\"); });\n            this.drawer.drawCardsToPass();\n        }\n        else if (this.game.winners.length) { // game over\n            this.drawer.drawPreviousTrick(); // I think this doesn't work\n            this.drawer.drawEnd(this.game.winners);\n        }\n        else {\n            this.drawer.drawHand((card) => { this.playCard(card); });\n            this.drawer.drawPlayedCards();\n            this.drawer.drawPreviousTrick();\n        }\n    }\n    click(e) {\n        console.log(\"gui click: \", e.x, e.y);\n        if (this.waiter.click()) {\n            return;\n        }\n        // have to go through clickables backwards\n        // because the one that is drawn last is on top and thus has priority for click\n        for (let i = this.clickables.length - 1; i >= 0; --i) {\n            if (this.clickables[i].contains(e.x, e.y)) {\n                this.clickables[i].onClick();\n                break; // only click on one thing at a time\n            }\n        }\n    }\n    handleMessage(messageData) {\n        if (messageData.value) {\n            // single card\n            // play it\n            console.log(\"received message from worker, turn:\", this.game.hand.getWhoseTurn());\n            this.waiter.gotMessage(new Card_1.default(messageData));\n        }\n        else {\n            // passing data\n            for (let fromPlayer = 1; fromPlayer < 4; ++fromPlayer) {\n                const toPlayer = (fromPlayer + this.game.getPassingDirection()) % 4;\n                const cardArray = [\n                    new Card_1.default(messageData[fromPlayer][0]),\n                    new Card_1.default(messageData[fromPlayer][1]),\n                    new Card_1.default(messageData[fromPlayer][2])\n                ];\n                this.game.hand.pass(fromPlayer, toPlayer, cardArray);\n            }\n        }\n    }\n    /**\n     * returns a promise resolved when were done waiting\n     * @param seconds\n     * @param allowSkipWithClick clicking the mouse skips the wait\n     * @param forPlay waiting for the next player to play a card\n     */\n    drawWait(seconds, allowSkipWithClick, forPlay) {\n        return this.waiter.wait(seconds, allowSkipWithClick, forPlay);\n    }\n    showReceivedCards() {\n        this.showingPassedCards = true;\n        return this.drawWait(3, true, false).then(() => {\n            this.showingPassedCards = false;\n            this.cardsToPass.clear();\n        });\n    }\n    computerTurn() {\n        this.workerMessagePlay();\n        this.drawWait(0.5, true, true).then((messageData) => {\n            this.game.hand.playCard(messageData);\n        });\n    }\n    // notifications from hand (handObserver interface)\n    resetHand() {\n        this.game.hand.dealHands();\n    }\n    dealHands() {\n        this.receivedCards.length = 0;\n        if (this.game.getPassingDirection()) {\n            this.humanPlayerPassed = false;\n            this.workerMessagePassing();\n        }\n        else {\n            this.game.hand.setPassed();\n            this.humanPlayerPassed = true;\n            this.drawer.setAiCards();\n            this.game.hand.resetTrick();\n        }\n    }\n    receivePassedCards() {\n        console.log(\"gui sees received passed cards\");\n        this.drawer.setAiCards();\n        this.game.hand.resetTrick();\n    }\n    resetTrick() {\n        if (this.game.hand.getWhoseTurn() !== 0) {\n            this.computerTurn();\n        }\n        else {\n            this.save();\n        }\n    }\n    pass(fromPlayer, _toPlayer, _cards) {\n        if (fromPlayer === 0) {\n            this.humanPlayerPassed = true;\n        }\n        if (this.game.hand.getPassCount() === 4) {\n            // show passed cards\n            this.receivedCards = this.game.hand.getPassedCardsToPlayer(0).slice();\n            // console.log(\"about to clear from pass function\");\n            this.cardsToPass.clear();\n            this.cardsToPass.insert(this.receivedCards[0]);\n            this.cardsToPass.insert(this.receivedCards[1]);\n            this.cardsToPass.insert(this.receivedCards[2]);\n            this.showReceivedCards().then(() => {\n                this.game.hand.receivePassedCards();\n            });\n        }\n        else if (this.game.hand.getPassCount() === 3) {\n            this.save();\n        }\n    }\n    seeCardPlayed(_card, _byPlayer, _showingOnlyHearts) {\n        console.log(\"see card played in GUI\");\n        // show card for 1 second, while next turn thinks\n        if (this.game.hand.getPlayedCardCount() === 4) {\n            // if the queen is in this trick, add to stats\n            if (this.game.hand.getPlayedCards().some((card) => {\n                return card.value === 12 && card.suit === Card_1.default.SPADES;\n            })) {\n                this.stats.queen(this.game.hand.getTrickLeader());\n            }\n            this.game.hand.endTrick();\n            this.drawWait(2, true, false).then(() => {\n                if (this.game.hand.getHand(0).length()) {\n                    this.game.hand.resetTrick();\n                }\n                else {\n                    console.log(\"last card of hand played\");\n                    const whoMoon = this.game.hand.endHand();\n                    this.game.endHand();\n                    this.stats.hand(whoMoon);\n                    // check for game end\n                    if (this.game.winners.length) {\n                        // game end\n                        this.stats.game(this.game.scores);\n                        this.deleteSave();\n                        this.drawWait(2, false, false).then(() => {\n                            this.drawWait(1000000, true, false).then(() => {\n                                this.game.reset();\n                                this.game.hand.resetHand(this.game.getPassingDirection());\n                            });\n                        });\n                    }\n                    else { // game not over\n                        // wait for animation of cards going away\n                        this.drawWait(0.5, true, false).then(() => {\n                            this.game.hand.resetHand(this.game.getPassingDirection());\n                        });\n                    }\n                }\n            });\n        }\n        else if (this.game.hand.getWhoseTurn() !== 0) { // (and not last turn in trick)\n            this.computerTurn();\n        }\n        else { // human turn\n            this.save();\n        }\n    }\n}\nexports.default = Gui;\n//# sourceMappingURL=Gui.js.map\n\n//# sourceURL=webpack:///./build/Gui.js?");

/***/ }),

/***/ "./build/Stats.js":
/*!************************!*\
  !*** ./build/Stats.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// TODO: a way to see stats\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass StatData {\n    constructor(jsonString) {\n        this.gameCount = 0;\n        this.handCount = 0;\n        /** first index is place-1, second index is player */\n        this.placeCounts = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n        /** index is player */\n        this.scoreTotals = [0, 0, 0, 0];\n        /** index is player */\n        this.bestScores = [999, 999, 999, 999];\n        /** index is player */\n        this.worstScores = [0, 0, 0, 0];\n        /** index is player */\n        this.moonCount = [0, 0, 0, 0];\n        /** index is player */\n        this.queenCount = [0, 0, 0, 0];\n        if (jsonString) {\n            // copy constructor\n            const obj = JSON.parse(jsonString);\n            this.gameCount = obj.gameCount;\n            this.handCount = obj.handCount;\n            this.placeCounts = obj.placeCounts;\n            this.scoreTotals = obj.scoreTotals;\n            this.bestScores = obj.bestScores;\n            this.worstScores = obj.worstScores;\n            this.moonCount = obj.moonCount;\n            this.queenCount = obj.queenCount;\n        }\n    }\n}\nclass Stats {\n    constructor(storage) {\n        this.data = new StatData();\n        this.queenWho = -1;\n        this.storage = storage;\n        this.init();\n    }\n    init() {\n        const statData = this.storage.getItem(\"statData\");\n        if (statData) {\n            this.data = new StatData(statData);\n        }\n        else {\n            this.data = new StatData();\n        }\n    }\n    save() {\n        this.storage.setItem(\"statData\", JSON.stringify(this.data));\n    }\n    queen(who) {\n        this.queenWho = who;\n    }\n    /**\n     * report statistics for a hand - queen(who) must be called first\n     * @param whoMoon who shot the moon, -1 if no one\n     */\n    hand(whoMoon) {\n        ++this.data.handCount;\n        if (this.queenWho === -1) {\n            console.log(\"ERROR: Stats: hand called without queen\");\n        }\n        else {\n            ++this.data.queenCount[this.queenWho];\n        }\n        this.queenWho = -1;\n        if (whoMoon !== -1) {\n            ++this.data.moonCount[whoMoon];\n        }\n        this.save();\n    }\n    game(scores) {\n        ++this.data.gameCount;\n        const sortedScores = scores.slice().sort((a, b) => a - b); // index is \"place-1\" (0 is first place, 1 is second...)\n        console.log(\"sorted scores:\");\n        console.log(sortedScores);\n        scores.forEach((score, player) => {\n            this.data.scoreTotals[player] += score;\n            if (score < this.data.bestScores[player]) {\n                this.data.bestScores[player] = score;\n            }\n            if (score > this.data.worstScores[player]) {\n                this.data.worstScores[player] = score;\n            }\n            const placeMinus1 = sortedScores.indexOf(score);\n            ++this.data.placeCounts[placeMinus1][player];\n        });\n        this.save();\n    }\n}\nexports.default = Stats;\n//# sourceMappingURL=Stats.js.map\n\n//# sourceURL=webpack:///./build/Stats.js?");

/***/ }),

/***/ "./build/Waiter.js":
/*!*************************!*\
  !*** ./build/Waiter.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Waiter {\n    constructor() {\n        this.waiting = false;\n        this.waitingTime = false;\n        this.clickSkips = true;\n        this.currentWait = null;\n        this.needMessage = false;\n        this.haveMessage = false;\n        this.messageData = undefined;\n        this.resolve = () => { };\n    }\n    /** returns whether this click canceled a wait */\n    click() {\n        if (this.waitingTime && this.clickSkips) {\n            clearTimeout(this.currentWait);\n            this.waitingTime = false;\n            this.checkFinish();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * returns a promise resolved when we're done waiting\n     * @param seconds\n     * @param allowSkipWithClick clicking the mouse skips the time requirement\n     * @param requireMessage gotMessage must be called for the promise to resolve\n     */\n    wait(seconds, allowSkipWithClick, requireMessage) {\n        this.waiting = true;\n        this.waitingTime = true;\n        this.clickSkips = allowSkipWithClick;\n        this.needMessage = requireMessage;\n        this.haveMessage = false;\n        console.log(\"need in middle of wait:\", this.needMessage);\n        this.currentWait = setTimeout(() => {\n            this.waitingTime = false;\n            this.checkFinish();\n        }, seconds * 1000);\n        return new Promise((resolve, _reject) => {\n            this.resolve = resolve;\n            this.checkFinish();\n        });\n    }\n    gotMessage(messageData) {\n        console.log(\"waiter got message\");\n        if (this.needMessage) {\n            console.log(\"waiter found needMessage true\");\n            this.haveMessage = true;\n            this.messageData = messageData;\n            this.checkFinish();\n        }\n    }\n    checkFinish() {\n        console.log(\"checking for wait finish\");\n        if (this.waiting &&\n            ((!this.waitingTime) && ((!this.needMessage) || this.haveMessage))) {\n            this.waiting = false;\n            this.needMessage = false;\n            this.haveMessage = false;\n            this.resolve(this.messageData);\n            this.messageData = undefined;\n            this.resolve = () => { };\n        }\n    }\n}\nexports.default = Waiter;\n//# sourceMappingURL=Waiter.js.map\n\n//# sourceURL=webpack:///./build/Waiter.js?");

/***/ }),

/***/ "./build/hearts.js":
/*!*************************!*\
  !*** ./build/hearts.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Gui_1 = __importDefault(__webpack_require__(/*! ./Gui */ \"./build/Gui.js\"));\nvar canvas = document.getElementById('c');\nvar assets = document.getElementById('a');\nvar storage = window.localStorage;\nconst gui = new Gui_1.default(canvas.getContext('2d'), assets, storage);\n// resize the canvas to fill browser window dynamically\nwindow.addEventListener('resize', resizeCanvas, false);\ncanvas.addEventListener('click', click, false);\nfunction resizeCanvas() {\n    console.log(\"browserZoomLevel: \" + window.devicePixelRatio);\n    canvas.width = window.innerWidth;\n    // I've looked at a lot of google search results and still can't find a good solution to this problem\n    // (how to get the height without the address bar on mobile)\n    // window.screen.availHeight - 20 (20 for android status bar) works on android but messes it up on desktop\n    canvas.height = Math.max(window.innerHeight, document.documentElement.clientHeight /*, window.screen.availHeight - 20*/);\n    gui.resize(Math.min(window.devicePixelRatio, 1)); // cards don't fit on the screen if zoom past 100%\n    gui.draw();\n}\nfunction click(e) {\n    gui.click(e);\n}\nfunction installServiceWorkerAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if ('serviceWorker' in navigator) {\n            try {\n                let serviceWorker = yield navigator.serviceWorker.register('sw.js');\n                console.log(`Service worker registered ${serviceWorker}`);\n            }\n            catch (err) {\n                console.error(`Failed to register service worker: ${err}`);\n            }\n        }\n    });\n}\nwindow.onload = function () {\n    resizeCanvas();\n    installServiceWorkerAsync();\n};\n//# sourceMappingURL=hearts.js.map\n\n//# sourceURL=webpack:///./build/hearts.js?");

/***/ })

/******/ });