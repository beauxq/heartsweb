/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/AI.js":
/*!*********************!*\
  !*** ./build/AI.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CardGroup_1 = __importDefault(__webpack_require__(/*! ./CardGroup */ \"./build/CardGroup.js\"));\nconst GameHand_1 = __importDefault(__webpack_require__(/*! ./GameHand */ \"./build/GameHand.js\"));\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nclass AI {\n    constructor(gameHand, whoAmI) {\n        this.pointsPlayedThisTrick = false;\n        this.shootMoonPossible = true;\n        this.unknownCards = new CardGroup_1.default();\n        this.playerSeenVoidInSuits = [];\n        this.cardsIPassed = []; // and not played yet, removed from here when they are seen played\n        if (gameHand.hasOwnProperty(\"whoAmI\")) {\n            // copy constructor\n            const ai = gameHand;\n            this.pointsPlayedThisTrick = ai.pointsPlayedThisTrick;\n            this.shootMoonPossible = ai.shootMoonPossible;\n            this.unknownCards = new CardGroup_1.default(ai.unknownCards);\n            this.playerSeenVoidInSuits = ai.playerSeenVoidInSuits;\n            this.cardsIPassed = [];\n            ai.cardsIPassed.forEach((card) => {\n                this.cardsIPassed.push(new Card_1.default(card));\n            });\n            this.gameHand = new GameHand_1.default(ai.gameHand);\n            this.whoAmI = ai.whoAmI;\n        }\n        else {\n            this.gameHand = gameHand;\n            this.whoAmI = whoAmI;\n            this.resetHand(); // just to be safe\n        }\n    }\n    speculateHands(passingDirection) {\n        const speculatedHands = [\n            new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default()\n        ];\n        const spaceRemainingIn = [\n            this.gameHand.getHand(0).length(),\n            this.gameHand.getHand(1).length(),\n            this.gameHand.getHand(2).length(),\n            this.gameHand.getHand(3).length()\n        ];\n        // I know my own hand\n        spaceRemainingIn[this.whoAmI] = 0;\n        const whomIPassedTo = (this.whoAmI + passingDirection) % 4;\n        spaceRemainingIn[whomIPassedTo] -= this.cardsIPassed.length;\n        function nonFullHands(player) { return spaceRemainingIn[player] > 0; }\n        ;\n        const handsThatAllowSuit = []; // first index is suit, second is player\n        for (let suit = 0; suit < 4; ++suit) {\n            handsThatAllowSuit.push([\n                !(this.playerSeenVoidInSuits[0][suit]),\n                !(this.playerSeenVoidInSuits[1][suit]),\n                !(this.playerSeenVoidInSuits[2][suit]),\n                !(this.playerSeenVoidInSuits[3][suit])\n            ]);\n        }\n        const allowSuitAndNonFull = []; // intersection of non-full-hands with hands that allow this suit\n        this.unknownCards.forEach((thisCard) => {\n            allowSuitAndNonFull.length = 0;\n            handsThatAllowSuit[thisCard.suit].forEach((allowThisSuit, player) => {\n                if (allowThisSuit && nonFullHands(player)) {\n                    allowSuitAndNonFull.push(player);\n                }\n            });\n            if (allowSuitAndNonFull.length) {\n                const receiver = allowSuitAndNonFull[Math.floor(Math.random() * allowSuitAndNonFull.length)];\n                speculatedHands[receiver].insert(thisCard);\n                --spaceRemainingIn[receiver];\n            }\n            else { // there are no hands left that allow this suit and have space for this card\n                // so we have to do some swapping\n                // find which suits are allowed in non-full hands\n                const suitsAllowedInNonFull = [false, false, false, false];\n                for (let player = 0; player < 4; ++player) {\n                    if (nonFullHands(player)) {\n                        for (let suit = 0; suit < 4; ++suit) {\n                            if (handsThatAllowSuit[suit][player]) {\n                                suitsAllowedInNonFull[suit] = true;\n                            }\n                        }\n                    }\n                }\n                // find possible cards to swap (out of those suits)\n                const possibleCards = [];\n                const fromPlayer = [];\n                // go through the hands that \"this card\" is allowed in\n                handsThatAllowSuit[thisCard.suit].forEach((allowed, player) => {\n                    if (allowed) {\n                        // go through the cards in this hand\n                        speculatedHands[player].forEach((card) => {\n                            // can this card go in a non-full hand?\n                            if (suitsAllowedInNonFull[card.suit]) {\n                                possibleCards.push(card);\n                                fromPlayer.push(player);\n                            }\n                        });\n                    }\n                });\n                if (possibleCards.length) {\n                    // do the swap\n                    const indexToSwap = Math.floor(Math.random() * possibleCards.length);\n                    /** intersection of non_full and allow swap suit */\n                    const allowSSANF = [];\n                    handsThatAllowSuit[possibleCards[indexToSwap].suit].forEach((allowed, player) => {\n                        if (allowed && nonFullHands(player)) {\n                            allowSSANF.push(player);\n                        }\n                    });\n                    // assert allowSSANF size > 0  // TODO: remove (or set up debugging)\n                    if (allowSSANF.length === 0) {\n                        console.log(\"ERROR: assertion fail, single swap, no place to put swap card\");\n                    }\n                    const receiver = allowSSANF[Math.floor(Math.random() * allowSSANF.length)];\n                    speculatedHands[receiver].insert(possibleCards[indexToSwap]);\n                    speculatedHands[fromPlayer[indexToSwap]].remove(possibleCards[indexToSwap]);\n                    // and this card in the space that was made for it\n                    speculatedHands[fromPlayer[indexToSwap]].insert(thisCard);\n                    // only the size of the non-full hand changed\n                    --spaceRemainingIn[receiver];\n                }\n                else { // no single swap possible, double swap is needed\n                    // assert: double swap is possible\n                    /* questionable assertion:\n                        There is a 3rd hand that is not involved in the previously used hands in this algorithm.\n                        One hand is full and is the only one that allows *this_card_itr\n                        A second hand is the only one not full and doesn't allow this card or any card in the first hand.\n                        The 3rd hand is full and must allow some suit that is in the first hand\n                                             and must have some suit that is allowed in the second hand. */\n                    const fullAndAllows = handsThatAllowSuit[thisCard.suit].indexOf(true); // \"1st hand\"\n                    let nonFull = 0; // \"2nd hand\"\n                    for (let player = 0; player < 4; ++player) {\n                        if (nonFullHands(player)) {\n                            nonFull = player;\n                            break;\n                        }\n                    }\n                    let thirdHand = 0;\n                    while ((thirdHand === fullAndAllows) ||\n                        (thirdHand === this.whoAmI) ||\n                        (thirdHand === nonFull)) {\n                        ++thirdHand;\n                    }\n                    // debugging assertions  // TODO: remove\n                    if (handsThatAllowSuit[thisCard.suit].length !== 1) {\n                        console.log(\"ERROR: big assertion was wrong, hands that allow this suit != 1\"); // !\n                    }\n                    // also, number of non full hands was 1\n                    // go through third hand and find cards allowed in non-full hand\n                    const secondSwapPossibilities = [];\n                    speculatedHands[thirdHand].forEach((card) => {\n                        if (suitsAllowedInNonFull[card.suit]) {\n                            secondSwapPossibilities.push(card);\n                        }\n                    });\n                    // another of the debugging assertions  // TODO: remove\n                    if (secondSwapPossibilities.length === 0) {\n                        console.log(\"ERROR: big assertion was wrong, no cards to move from 3rd to 2nd\");\n                    }\n                    // move one of those cards to the non-full hand\n                    const secondSwap = secondSwapPossibilities[Math.floor(Math.random() *\n                        secondSwapPossibilities.length)];\n                    speculatedHands[nonFull].insert(secondSwap);\n                    speculatedHands[thirdHand].remove(secondSwap);\n                    --spaceRemainingIn[nonFull];\n                    // find cards that can be moved from first hand to third hand\n                    // possibleCards is already declared from way before and is empty\n                    speculatedHands[fullAndAllows].forEach((card) => {\n                        if (!(this.playerSeenVoidInSuits[thirdHand][card.suit])) {\n                            possibleCards.push(card);\n                        }\n                    });\n                    // another of the debugging assertions  // TODO: remove\n                    if (possibleCards.length === 0) {\n                        console.log(\"ERROR: big assertion was wrong, no cards to move from 1st to 3rd\");\n                    }\n                    // move one of those cards to the third hand\n                    const firstLevelSwap = possibleCards[Math.floor(Math.random() *\n                        possibleCards.length)];\n                    speculatedHands[thirdHand].insert(firstLevelSwap);\n                    speculatedHands[fullAndAllows].remove(firstLevelSwap);\n                    // so now it's not full and has space for this card\n                    // (it will be full right after inserting this card, so don't change space remaining)\n                    // Now, finally, we can get rid of this card\n                    speculatedHands[fullAndAllows].insert(thisCard);\n                } // done with double swap\n            } // done with any swapping\n        }); // next card\n        // put in the cards that I already knew\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            speculatedHands[this.whoAmI].insert(card);\n        });\n        this.cardsIPassed.forEach((card) => {\n            speculatedHands[whomIPassedTo].insert(card);\n        });\n        return speculatedHands;\n    }\n    resetHand() {\n        this.unknownCards.fill();\n        this.cardsIPassed.length = 0;\n        this.playerSeenVoidInSuits = [\n            [false, false, false, false],\n            [false, false, false, false],\n            [false, false, false, false],\n            [false, false, false, false]\n        ];\n        this.shootMoonPossible = true;\n    }\n    dealHands() {\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            this.unknownCards.remove(card);\n        });\n    }\n    pass(fromPlayer, toPlayer, cards) {\n        if (fromPlayer === this.whoAmI) {\n            this.cardsIPassed = cards.slice();\n        }\n    }\n    receivePassedCards() {\n        this.gameHand.getHand(this.whoAmI).forEach((card) => {\n            this.unknownCards.remove(card);\n        });\n    }\n    resetTrick() {\n        this.pointsPlayedThisTrick = false;\n    }\n    seeCardPlayed(card, byPlayer, showingOnlyHearts = false) {\n        if (this.gameHand.pointsFor(card)) {\n            this.pointsPlayedThisTrick = true;\n        }\n        this.unknownCards.remove(card);\n        // remove from passed cards\n        let indexInPassed = -1;\n        this.cardsIPassed.forEach((passedCard, index) => {\n            if (card.value === passedCard.value && card.suit === passedCard.suit) {\n                indexInPassed = index;\n            }\n        });\n        if (indexInPassed !== -1) {\n            this.cardsIPassed.splice(indexInPassed, 1);\n        }\n        // is player showing they have none of a suit?\n        const leadSuit = this.gameHand.getPlayedCards()[this.gameHand.getTrickLeader()].suit;\n        if (card.suit !== leadSuit) {\n            this.playerSeenVoidInSuits[byPlayer][leadSuit] = true;\n        }\n        // showing that they only have hearts?\n        if (showingOnlyHearts) {\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.CLUBS] = true;\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.DIAMONDS] = true;\n            this.playerSeenVoidInSuits[byPlayer][Card_1.default.SPADES] = true;\n        }\n        // see if it's still possible to shoot the moon\n        if (this.shootMoonPossible) {\n            if (this.pointsPlayedThisTrick) {\n                let nonZeroScore = -1;\n                for (let player = 0; player < 4; ++player) {\n                    if (this.gameHand.getScore(player)) {\n                        nonZeroScore = player;\n                        break;\n                    }\n                }\n                if (nonZeroScore !== -1) {\n                    // see whether this player has played yet this trick\n                    let thisPlayerPLayed = false;\n                    let goingThroughTurns = (this.gameHand.getWhoseTurn() + 5 - this.gameHand.getPlayedCardCount()) % 4; // first turn this trick\n                    for (let turn = this.gameHand.getPlayedCardCount(); turn > 0; --turn) {\n                        if (goingThroughTurns === nonZeroScore) {\n                            thisPlayerPLayed = true;\n                            break;\n                        }\n                        goingThroughTurns = (goingThroughTurns + 1) % 4;\n                    }\n                    if (thisPlayerPLayed) {\n                        if (nonZeroScore !== this.gameHand.getTrickLeader()) {\n                            this.shootMoonPossible = false;\n                        }\n                        // for testing\n                        console.log(\"this is the point when it becomes impossible for anyone to shoot the moon\");\n                    }\n                }\n            }\n        }\n    }\n    staticPlayAI() {\n        const validChoices = this.gameHand.findValidChoices();\n        if (this.gameHand.getPlayedCardCount() > 0) { // I'm not leading the trick\n            const leadCard = this.gameHand.getPlayedCards()[this.gameHand.getTrickLeader()];\n            if (validChoices[0].suit === leadCard.suit) { // I have to follow suit\n                if (validChoices[0].value < leadCard.value) { // I can play under, avoid taking it\n                    // find highest card I can avoid taking it with\n                    for (let i = validChoices.length - 1; i >= 0; --i) {\n                        if (validChoices[i].value < leadCard.value) { // this is highest card I can avoid taking it with\n                            // Q of Spades instead of K of Spades\n                            if (validChoices[i].value === 13 && // king\n                                validChoices[i].suit === Card_1.default.SPADES && // of spades\n                                i > 0 && // I have a lower spade\n                                validChoices[i - 1].value === 12 // and it's the queen\n                            ) {\n                                return validChoices[i - 1];\n                            }\n                            else { // not k and q of spades\n                                return validChoices[i]; // highest card I can avoid taking it with\n                            }\n                        }\n                    }\n                    console.log(\"ERROR: should never get here\");\n                    return validChoices[0]; // just so compiler doesn't complain about not returning a card\n                }\n                else { // I can't play under\n                    if (this.gameHand.getPlayedCardCount() < 3) { // someone else will play after me\n                        if (leadCard.suit === Card_1.default.SPADES) { // spades\n                            if (validChoices[0].value === 12 && // queen\n                                validChoices.length > 1) { // and I have somethign else\n                                return validChoices[1];\n                            }\n                            else { // not queen or I don't have anything else\n                                return validChoices[0];\n                            }\n                        }\n                        else { // not spades\n                            return validChoices[0];\n                        }\n                    }\n                    else { // no one else plays after me\n                        const highestCard = validChoices[validChoices.length - 1];\n                        if (leadCard.suit === Card_1.default.SPADES) { // spades\n                            if (highestCard.value === 12 && // queen\n                                validChoices.length > 1 // and I have something else\n                            ) {\n                                return validChoices[validChoices.length - 2]; // highest except queen\n                            }\n                            else { // not queen or I don't ahve anything is\n                                return highestCard;\n                            }\n                        }\n                        else { // not spades\n                            return highestCard;\n                        }\n                    }\n                }\n            }\n            else { // don't have to follow suit (and not leading)\n                // GET RID OF THE QUEEN!!\n                // (play lowest of high spades)\n                const highSpades = []; // ordered from highest to lowest\n                for (let i = validChoices.length - 1; i >= 0; --i) {\n                    if (validChoices[i].suit !== Card_1.default.SPADES) {\n                        continue;\n                    }\n                    if (validChoices[i].value > 11) { // higher than jack\n                        highSpades.push(validChoices[i]);\n                    }\n                    else { // spade, lower than queen\n                        break;\n                    }\n                }\n                if (highSpades.length) { // I have high spades\n                    return highSpades[highSpades.length - 1]; // play lowest high spade\n                }\n                else { // I don't have any high spades\n                    // play the highest card in the suit of the highest lowest card of its suit\n                    // (yes, you understood that)\n                    // algorithm:\n                    // look at the lowest card in each suit\n                    // which one of those is the highest?\n                    // what's the suit of that card?\n                    // play the highest card in that suit\n                    let currentSuit = validChoices[0].suit;\n                    let sothlcois = currentSuit; // suit of the highest lowest card of its suit\n                    let lowestValue = validChoices[0].value; // in that suit\n                    for (let i = 1; i < validChoices.length; ++i) {\n                        if (validChoices[i].suit !== currentSuit) { // moved into new suit\n                            currentSuit = validChoices[i].suit;\n                            if (validChoices[i].value // lowest value in this suit\n                                > lowestValue // found one higher\n                            ) {\n                                sothlcois = currentSuit;\n                                lowestValue = validChoices[i].value;\n                            }\n                        }\n                    }\n                    // now we know the suit of the highest lowest card of its suit\n                    // since we don't have any high spades, any card of this suit should be a valid choice\n                    // so we can pull it out of the hand (instead of the valid_choices)\n                    const cardsInSuit = this.gameHand.getHand(this.gameHand.getWhoseTurn()).getSuit(sothlcois);\n                    return cardsInSuit[cardsInSuit.length - 1];\n                }\n            }\n        }\n        else { // I lead\n            const nonHighSpades = validChoices.filter((card) => {\n                return (card.value < 12 || card.suit !== Card_1.default.SPADES);\n            });\n            if (nonHighSpades.length) {\n                // found something that's not high spade\n                // random (without high spades)\n                return nonHighSpades[Math.floor(Math.random() * nonHighSpades.length)];\n            }\n            // else only high spades available\n            return validChoices[0]; // play lowest high spade\n        }\n        /*\n                    let foundNonHighSpade = false;\n                    for (let i = 0; i < validChoices.length; --i) {\n                        if (validChoices[i].value < 12 || validChoices[i].suit !== Card.SPADES) {\n                            // found something that's not high spade\n                            foundNonHighSpade = true;\n                            break;\n                        }\n                    }\n                    if (! foundNonHighSpade) {  // only high spades available\n                        return validChoices[0];  // play lowest high spade\n                    }\n                    // random, but not high spade\n                    let lengthWOHighSpades = validChoices.length;\n                    let randomIndex;\n                    while (true) {\n                        randomIndex = Math.floor(Math.random() * lengthWOHighSpades);\n                        if (validChoices[randomIndex].value > 11 && validChoices[randomIndex].suit === Card.SPADES) {  // high spade\n                            // swap high spade into last spot\n                            // I stopped here and decided to use filter instead\n                        }\n                    }\n                }\n                */\n    }\n}\nexports.default = AI;\n//# sourceMappingURL=AI.js.map\n\n//# sourceURL=webpack:///./build/AI.js?");

/***/ }),

/***/ "./build/Card.js":
/*!***********************!*\
  !*** ./build/Card.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Card {\n    constructor(value, suit) {\n        if (value.hasOwnProperty(\"suit\")) {\n            // copy constructor\n            const card = value;\n            this.value = card.value;\n            this.suit = card.suit;\n        }\n        else {\n            this.value = value;\n            this.suit = suit;\n        }\n    }\n    /**\n     * binary search a sorted Card array for a card,\n     * return index, -1 if not found\n     * @param sortedArray\n     * @param card\n     * @param beginIndex\n     * @param endIndexPlus1\n     */\n    static find(sortedArray, card, beginIndex = 0, endIndexPlus1 = sortedArray.length) {\n        const looking = Math.floor((beginIndex + endIndexPlus1) / 2);\n        if (looking >= endIndexPlus1) {\n            return -1;\n        }\n        if (sortedArray[looking].value === card.value) {\n            return looking;\n        }\n        if (sortedArray[looking].value > card.value) {\n            return Card.find(sortedArray, card, beginIndex, looking);\n        }\n        // else looking < card\n        return Card.find(sortedArray, card, looking + 1, endIndexPlus1);\n    }\n    str() {\n        let to_return;\n        switch (this.value) {\n            case 1:\n            case 14:\n                to_return = \"Ace of \";\n                break;\n            case 11:\n                to_return = \"Jack of \";\n                break;\n            case 12:\n                to_return = \"Queen of \";\n                break;\n            case 13:\n                to_return = \"King of \";\n                break;\n            default:\n                to_return = this.value.toString();\n                to_return += \" of \";\n        }\n        switch (this.suit) {\n            case Card.CLUBS:\n                to_return += \"Clubs\";\n                break;\n            case Card.DIAMONDS:\n                to_return += \"Diamonds\";\n                break;\n            case Card.SPADES:\n                to_return += \"Spades\";\n                break;\n            case Card.HEARTS:\n                to_return += \"Hearts\";\n                break;\n            default:\n                to_return += \"UNKNOWN SUIT\";\n        }\n        return to_return;\n    }\n}\nCard.CLUBS = 0;\nCard.DIAMONDS = 1;\nCard.SPADES = 2;\nCard.HEARTS = 3;\nCard.SUIT_COUNT = 4;\nexports.default = Card;\n//# sourceMappingURL=Card.js.map\n\n//# sourceURL=webpack:///./build/Card.js?");

/***/ }),

/***/ "./build/CardGroup.js":
/*!****************************!*\
  !*** ./build/CardGroup.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nclass CardGroup {\n    constructor(cardGroup) {\n        this.cards = [\n            [], [], [], [] // one for each suit\n        ];\n        if (cardGroup) {\n            // copy constructor\n            cardGroup.cards.forEach((suitArray, suitIndex) => {\n                suitArray.forEach((card) => {\n                    this.cards[suitIndex].push(new Card_1.default(card));\n                });\n            });\n        }\n    }\n    /**\n     * the number of cards in given suit\n     *  - if no suit given, the number of cards in all suits\n     * @param suit\n     */\n    length(suit = -1) {\n        if (suit === -1) {\n            return this.cards[0].length + this.cards[1].length + this.cards[2].length + this.cards[3].length;\n        }\n        return this.cards[suit].length;\n    }\n    getSuitAndIndex(fullIndex) {\n        let suit = 0;\n        while (suit < 4 && fullIndex >= this.cards[suit].length) {\n            fullIndex -= this.cards[suit].length;\n            suit += 1;\n        }\n        if (suit < 4) {\n            return {\n                suit: suit,\n                index: fullIndex\n            };\n        }\n        return null;\n    }\n    at(index) {\n        const suitAndIndex = this.getSuitAndIndex(index);\n        if (suitAndIndex)\n            return this.cards[suitAndIndex.suit][suitAndIndex.index];\n        return null;\n    }\n    forEach(callback) {\n        let index = 0;\n        this.cards.forEach((suit) => {\n            suit.forEach((card) => {\n                callback(card, index);\n                ++index;\n            });\n        });\n    }\n    /**\n     * returns index, -1 if not present\n     * @param card\n     */\n    find(card) {\n        let indexToReturn = Card_1.default.find(this.cards[card.suit], card);\n        if (indexToReturn === -1) {\n            return -1;\n        }\n        for (let suit = 0; suit < card.suit; ++suit) {\n            indexToReturn += this.cards[suit].length;\n        }\n        return indexToReturn;\n    }\n    remove(cardOrIndex) {\n        let indexInSuitArray, arrayToRemoveFrom;\n        if (cardOrIndex instanceof Card_1.default) {\n            arrayToRemoveFrom = this.cards[cardOrIndex.suit];\n            indexInSuitArray = Card_1.default.find(arrayToRemoveFrom, cardOrIndex);\n            if (indexInSuitArray === -1) {\n                return;\n            }\n        }\n        else { // cardOrIndex is index\n            const suitAndIndex = this.getSuitAndIndex(cardOrIndex);\n            if (!suitAndIndex) {\n                return;\n            }\n            arrayToRemoveFrom = this.cards[suitAndIndex.suit];\n            indexInSuitArray = suitAndIndex.index;\n        }\n        arrayToRemoveFrom.splice(indexInSuitArray, 1);\n    }\n    insert(card) {\n        const arrayToInsertTo = this.cards[card.suit];\n        let i = 0;\n        for (; i < arrayToInsertTo.length; ++i) {\n            if (arrayToInsertTo[i].value > card.value) {\n                break;\n            }\n        }\n        arrayToInsertTo.splice(i, 0, card);\n    }\n    clear() {\n        this.cards.forEach((suitArray) => {\n            suitArray.length = 0;\n        });\n    }\n    /**\n     * fill with 52 cards\n     */\n    fill() {\n        this.cards.forEach((suitArray, suitNumber) => {\n            suitArray.length = 0;\n            for (let i = 2; i < 15; ++i) {\n                suitArray.push(new Card_1.default(i, suitNumber));\n            }\n        });\n    }\n    dealOne() {\n        const index = Math.floor(Math.random() * this.length());\n        const toReturn = this.at(index);\n        this.remove(index);\n        // @ts-ignore trust me, it will not be null\n        return toReturn;\n    }\n    getSuit(suit) {\n        return this.cards[suit];\n    }\n    slice() {\n        return this.cards[0].concat(this.cards[1], this.cards[2], this.cards[3]);\n    }\n}\nexports.default = CardGroup;\n//# sourceMappingURL=CardGroup.js.map\n\n//# sourceURL=webpack:///./build/CardGroup.js?");

/***/ }),

/***/ "./build/GameHand.js":
/*!***************************!*\
  !*** ./build/GameHand.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CardGroup_1 = __importDefault(__webpack_require__(/*! ./CardGroup */ \"./build/CardGroup.js\"));\nconst Card_1 = __importDefault(__webpack_require__(/*! ./Card */ \"./build/Card.js\"));\nconst nullCard = new Card_1.default(0, 0);\n/**\n * each hand, call these in this order:\n * resetHand();\n * dealHands();\n * pass(fromPlayer, toPlayer, passedCards);\n * receivePassedCards();  // TODO: return which cards (for UI)\n * resetTrick();\n * playCard(card);  // TODO: return hearts broken (for UI)\n * endTrick();  // TODO: returns who took the trick? (for UI)\n * endHand();  // returns who shot the moon\n */\nclass GameHand {\n    constructor(gameHand) {\n        this.hands = [new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default(), new CardGroup_1.default()];\n        this.scores = [0, 0, 0, 0];\n        this.passedCardsToPlayer = [[], [], [], []]; // first index is player passed to\n        this.passCount = 0;\n        // trick\n        this.playedCards = [nullCard, nullCard, nullCard, nullCard];\n        this.playedCardCount = 0;\n        this.trickLeader = 0;\n        this.whoseTurn = 0;\n        this.heartsBroken = false;\n        this.observerList = [];\n        if (gameHand) {\n            // copy constructor\n            this.hands[0] = new CardGroup_1.default(gameHand.hands[0]);\n            this.hands[1] = new CardGroup_1.default(gameHand.hands[1]);\n            this.hands[2] = new CardGroup_1.default(gameHand.hands[2]);\n            this.hands[3] = new CardGroup_1.default(gameHand.hands[3]);\n            this.scores = gameHand.scores;\n            for (let player = 0; player < 4; ++player) {\n                gameHand.passedCardsToPlayer[player].forEach((card) => {\n                    this.passedCardsToPlayer[player].push(new Card_1.default(card));\n                });\n            }\n            this.passCount = gameHand.passCount;\n            this.playedCards[0] = new Card_1.default(gameHand.playedCards[0]);\n            this.playedCards[1] = new Card_1.default(gameHand.playedCards[1]);\n            this.playedCards[2] = new Card_1.default(gameHand.playedCards[2]);\n            this.playedCards[3] = new Card_1.default(gameHand.playedCards[3]);\n            this.playedCardCount = gameHand.playedCardCount;\n            this.trickLeader = gameHand.trickLeader;\n            this.whoseTurn = gameHand.whoseTurn;\n            this.heartsBroken = gameHand.heartsBroken;\n            // don't copy observer list\n        }\n    }\n    registerObserver(ob) {\n        this.observerList.push(ob);\n    }\n    getWhoseTurn() {\n        return this.whoseTurn;\n    }\n    getHand(player) {\n        return this.hands[player];\n    }\n    getScore(player) {\n        return this.scores[player];\n    }\n    turnsLeftInTrick() {\n        return 4 - this.playedCardCount;\n    }\n    heartsIsBroken() {\n        return this.heartsBroken;\n    }\n    getPassCount() {\n        return this.passCount;\n    }\n    getPlayedCards() {\n        return this.playedCards;\n    }\n    getPlayedCardCount() {\n        return this.playedCardCount;\n    }\n    getTrickLeader() {\n        return this.trickLeader;\n    }\n    getPassedCardsToPlayer(player) {\n        return this.passedCardsToPlayer[player];\n    }\n    /**\n     * to be called on keeper hand to say we're done passing\n     */\n    setPassed() {\n        this.passCount = 4;\n    }\n    resetHand() {\n        for (let i = 0; i < 4; ++i) {\n            this.hands[i].clear();\n            this.scores[i] = 0;\n            this.passedCardsToPlayer[i].length = 0;\n        }\n        this.passCount = 0;\n        this.heartsBroken = false;\n        this.observerList.forEach((ob) => { ob.resetHand(); });\n    }\n    dealHands() {\n        const deck = new CardGroup_1.default();\n        deck.fill();\n        while (deck.length()) {\n            for (let i = 0; i < 4; ++i) {\n                const dealt = deck.dealOne();\n                this.hands[i].insert(dealt);\n                if (dealt.value === 2 && dealt.suit === Card_1.default.CLUBS) {\n                    this.whoseTurn = i;\n                }\n            }\n        }\n        this.observerList.forEach((ob) => { ob.dealHands(); });\n    }\n    pass(fromPlayer, toPlayer, cards) {\n        cards.forEach((card) => {\n            this.passedCardsToPlayer[toPlayer].push(card);\n            this.hands[fromPlayer].remove(card);\n        });\n        ++this.passCount;\n        this.observerList.forEach((ob) => { ob.pass(fromPlayer, toPlayer, cards); });\n    }\n    receivePassedCards() {\n        for (let playerIndex = 0; playerIndex < 4; ++playerIndex) {\n            this.passedCardsToPlayer[playerIndex].forEach((card) => {\n                this.hands[playerIndex].insert(card);\n                if (card.value === 2 && card.suit === Card_1.default.CLUBS) {\n                    this.whoseTurn = playerIndex;\n                }\n            });\n        }\n        this.observerList.forEach((ob) => { ob.receivePassedCards(); });\n    }\n    resetTrick() {\n        this.playedCards = [nullCard, nullCard, nullCard, nullCard];\n        this.playedCardCount = 0;\n        this.trickLeader = this.whoseTurn;\n        this.observerList.forEach((ob) => { ob.resetTrick(); });\n    }\n    takesLead(card) {\n        return (card.suit === this.playedCards[this.trickLeader].suit &&\n            card.value > this.playedCards[this.trickLeader].value);\n    }\n    playCard(card) {\n        this.hands[this.whoseTurn].remove(card);\n        this.playedCards[this.whoseTurn] = card;\n        ++this.playedCardCount;\n        if (this.takesLead(card)) {\n            this.trickLeader = this.whoseTurn;\n        }\n        let showingOnlyHearts = false;\n        if (card.suit === Card_1.default.HEARTS) {\n            if (this.playedCardCount === 1 && !this.heartsBroken) {\n                showingOnlyHearts = true;\n            }\n            this.heartsBroken = true; // TODO: alternate rule q of spades breaks hearts?\n        }\n        // observer here before whoseTurn is changed\n        this.observerList.forEach((ob) => { ob.seeCardPlayed(card, this.whoseTurn, showingOnlyHearts); });\n        this.whoseTurn = (this.whoseTurn + 1) % 4;\n    }\n    pointsFor(card) {\n        return (card.suit === Card_1.default.HEARTS) ? 1 : ((card.value === 12 && card.suit === Card_1.default.SPADES) ? 13 : 0);\n    }\n    endTrick() {\n        this.playedCards.forEach((card) => {\n            this.scores[this.trickLeader] += this.pointsFor(card);\n        });\n        this.whoseTurn = this.trickLeader;\n        // TODO: history of tricks?\n    }\n    /**\n     * returns who shot the moon, -1 if no one\n     */\n    endHand() {\n        for (let winPlayer = 0; winPlayer < 4; ++winPlayer) { // check for shoot the moon\n            if (this.scores[winPlayer] === 26) {\n                this.scores[winPlayer] = 0;\n                for (let losePlayer = 0; losePlayer < 4; ++losePlayer) {\n                    if (losePlayer !== winPlayer) {\n                        this.scores[losePlayer] = 26;\n                    }\n                }\n                return winPlayer;\n            }\n            else if (this.scores[winPlayer] > 0) { // 1 to 25 points\n                return -1;\n            }\n        }\n        alert(\"this should never happen, invalid scores\");\n        console.log(\"this should never happen, invalid scores\");\n        return -2;\n    }\n    // rules of the game\n    findValidChoices() {\n        const hand = this.hands[this.whoseTurn];\n        if (hand.length() === 13) { // first trick\n            if (this.playedCardCount === 0) { // first player\n                return [new Card_1.default(2, Card_1.default.CLUBS)];\n            }\n            // not first player\n            if (hand.length(Card_1.default.CLUBS)) {\n                return hand.getSuit(Card_1.default.CLUBS).slice();\n            }\n            else { // no clubs\n                const validChoices = [];\n                hand.forEach((card) => {\n                    if (!this.pointsFor(card)) {\n                        validChoices.push(card);\n                    }\n                });\n                if (validChoices.length) {\n                    return validChoices;\n                }\n                // only points in hand\n                return hand.slice();\n            }\n        }\n        else { // not first trick\n            if (this.playedCardCount === 0) { // leading trick\n                if (this.heartsBroken) {\n                    return hand.slice();\n                }\n                // hearts not broken\n                if (hand.length(Card_1.default.HEARTS) === hand.length()) { // only hearts in hand\n                    return hand.slice();\n                }\n                // hearts in hand, play anything not hearts\n                const validChoices = [];\n                hand.forEach((card) => {\n                    if (card.suit !== Card_1.default.HEARTS) {\n                        validChoices.push(card);\n                    }\n                });\n                return validChoices;\n            }\n            else { // not leading trick\n                if (hand.length(this.playedCards[this.trickLeader].suit)) { // have suit that is lead\n                    return hand.getSuit(this.playedCards[this.trickLeader].suit);\n                }\n                // don't have matching suit\n                return hand.slice();\n            }\n        }\n    }\n}\nexports.default = GameHand;\n//# sourceMappingURL=GameHand.js.map\n\n//# sourceURL=webpack:///./build/GameHand.js?");

/***/ }),

/***/ "./build/worker.js":
/*!*************************!*\
  !*** ./build/worker.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AI_1 = __importDefault(__webpack_require__(/*! ./AI */ \"./build/AI.js\"));\naddEventListener('message', (message) => {\n    console.log('in webworker', message);\n    if (message.data.length) {\n        // AI array\n        const ai1 = new AI_1.default(message.data[1]);\n        console.log(ai1.staticPlayAI());\n    }\n    // postMessage('this is the response ', \"\");\n});\n//# sourceMappingURL=worker.js.map\n\n//# sourceURL=webpack:///./build/worker.js?");

/***/ })

/******/ });